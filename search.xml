<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React源码解析(一):组件的实现与挂载]]></title>
    <url>%2F2018%2F12%2F11%2FReactSource1%2F</url>
    <content type="text"><![CDATA[当我们能够熟练运用React进行前端开发时，不免会对React内部机制产生浓厚的兴趣。组件是什么？是真的DOM吗？生命周期函数的执行依据又是什么呢？ 本篇，我们先来研究React组件的实现与挂载。 组件是什么首先编写一个最简单的组件：1234567891011121314import React, &#123; Component &#125; from 'react';class A extends Component &#123; constructor(props)&#123; super(props); this.state = &#123;&#125;; &#125; componentDidMount()&#123;&#125; render()&#123; return &lt;div&gt;这是A组件&lt;/div&gt; &#125;&#125; 上述代码写完后，我们就得到了&lt;A /&gt;这个组件，那么我们接下来先弄清楚&lt;A /&gt;是什么。用console.log打印出来： 可以看出，&lt;A /&gt;其实是js对象而不是真实的DOM，注意此时props是空对象。接下来，我们打印&lt;A&gt;&lt;div&gt;这是A组件&lt;/div&gt;&lt;/A&gt;，看看控制台会输出什么： 我们看到，props发生了变化，由于&lt;A /&gt;组件中嵌套了一个div，div中又嵌套了文字，所以在描述&lt;A /&gt;对象的props中增加了children属性，其值为描述div的js对象。同理，如果我们进行多层的组件嵌套，其实就是在父对象的props中增加children字段及对应的描述值，也就是js对象的多层嵌套。 以上描述是基于ES6的React开发模式，其实在ES5中通过React.createClass({})方法创建的组件，与ES6中是完全一样的，同样可以通过控制台打印输出组件结果进行验证，此处不再赘述。 那么形如HTML标签实际上却是对象的React组件是如何构成的呢？ 因为我们的组件声明基于React和Component，所以首先我们打开React.js,可以看到如下代码: 123456var React = &#123; Component: ReactComponent, createElement: createElement, createClass: ReactClass.createClass,&#125;;module.exports = React; 我们在import React from &#39;react&#39;时，引入的就是源码中提供的React对象。在extends Component时，继承了Component类。这里需要说明两点： 源码中明明使用的module.exports而不是export default，为什么还能够成功引入呢？其实这是babel解析器的功劳。它令(ES6)import === (CommonJS)require。而在typescript中，需要严格的export default声明，故在typescript下就不能使用import React from &#39;react&#39;了，有兴趣的读者可以尝试一下。我们可以写extends Component也可以写extends React.Component，这两者是否存在区别呢？答案是否定的。因为Component是React.Component的引用。也就是说Component === React.Component，在实际项目中写哪个都可以。 沿着ReactComponent的线索，我们打开node_modules/react/lib/ReactComponent.js: 12345678910111213141516function ReactComponent(porps, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue&#125;ReactComponent.prototype.setState = function() &#123; // ...&#125;;ReactComponent.prototype.forceUpdate = function() &#123; //...&#125;;module.exports = ReactComponent; 上述代码是再熟悉不过的构造函数，想必大家已经滚瓜烂熟了。同时我们也注意到setState是定义在原型上具有两个参数的方法，具体原理我们将在React更新机制的篇章讲解。 上述代码表明，我们在最开始声明的组件A，其实是继承ReactComponent类的子类，它的原型具有setState等方法。这样组件A已经有了最基本的雏形。 小结 组件的初始化声明A后，我们可以在其内部自定义方法，也可以使用生命周期的方法，如ComponentDidMount等等，这些和我们在写”类”的时候是完全一样的。唯一不同的是组件类必须拥有render方法输出类似&lt;div&gt;这是A组件&lt;/div&gt;的结构并挂载到真实DOM上，才能触发组件的生命周期并成为DOM树的一部分。首先我们观察ES6的”类”是如何初始化一个react组件的。 将最初的示例代码放入babel中： 1234567891011121314151617var A = function(_Component)&#123; // _inherits(A,_component); function A()&#123; _classCallCheck(this,A); var _this = _possibleConstructorReturn(this,_Component.call(this)); _this.state = &#123;&#125;; return _this; &#125; A.prototype.render = function()&#123; return React.createElement('div',null); &#125; return A;&#125;(Component); 其中_Component是对象ReactComponent，_inherit方法是extends关键字的函数实现，这些都是ES6相关内容，我们暂时不管。关键在于我们发现render方法实际上是调用了React.createElement方法(实际是ReactElement方法)。然后我们打开ReactElement.js: 12345678910111213var ReactElement = function(type, key, ref, self, source, owner, props) &#123; var element = &#123; $$typeof: REACT_ELEMENT_TYPE, type: type, key: key, ref: ref, props: props, _owner: owner &#125;; return element;&#125; 参数 功能 $$typeof 组件的标识信息 key DOM结构标识，提升update性能 props 子结构相关信息(有则增加children字段/没有为空)和组件属性(如style) ref 真实DOM的引用 _owner _owner === ReactCurrentOwner.current(ReactCurrentOwner.js),值为创建当前组件的对象，默认值为null。 看完上述内容相信大家已经对React组件的实质有了一定的了解。通过执行React.createElement创建出的ReactElement类型的js对象，就是”React组件”，这与控制台打印出的结果完全对应。总结来说，如果我们通过class关键字声明React组件,那么他们在解析成真实DOM之前一直是ReactElement类型的js对象。 小结 对之前的思维导图进行补充： 组件的挂载我们知道可以通过ReactDOM.render(component,mountNode)的形式对自定义组件/原生DOM/字符串进行挂载， 那么挂载的过程又是如何实现的呢？(我们去除中间的一些逻辑判断) ReactDOM.render实际调用了内部的ReactMount.render，进而执行ReactMount._renderSubtreeIntoContainer。从字面意思上就可以看出是将”子DOM”插入容器的逻辑，我们看下源码实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061_renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) &#123; var nextWrappedElement = React.createElement(TopLevelWrapper, &#123; child: nextElement &#125;); var nextContext; if (parentComponent) &#123; var parentInst = ReactInstanceMap.get(parentComponent); nextContext = parentInst._processChildContext(parentInst._context); &#125; else &#123; nextContext = emptyObject; &#125; var prevComponent = getTopLevelWrapperInContainer(container); if (prevComponent) &#123; var prevWrappedElement = prevComponent._currentElement; var prevElement = prevWrappedElement.props.child; //组件更新在生命周期部分进行解析 if (shouldUpdateReactComponent(prevElement, nextElement)) &#123; var publicInst = prevComponent._renderedComponent.getPublicInstance(); var updatedCallback = callback &amp;&amp; function () &#123; callback.call(publicInst); &#125;; //更新组件 ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback); return publicInst; &#125; else &#123; //卸载 ReactMount.unmountComponentAtNode(container); &#125; &#125; var reactRootElement = getReactRootElementInContainer(container); var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement); var containerHasNonRootReactChild = hasNonRootReactChild(container); if (process.env.NODE_ENV !== &apos;production&apos;) &#123; process.env.NODE_ENV !== &apos;production&apos; ? warning(!containerHasNonRootReactChild, &apos;render(...): Replacing React-rendered children with a new root &apos; + &apos;component. If you intended to update the children of this node, &apos; + &apos;you should instead have the existing children update their state &apos; + &apos;and render the new components instead of calling ReactDOM.render.&apos;) : void 0; if (!containerHasReactMarkup || reactRootElement.nextSibling) &#123; var rootElementSibling = reactRootElement; while (rootElementSibling) &#123; if (internalGetID(rootElementSibling)) &#123; process.env.NODE_ENV !== &apos;production&apos; ? warning(false, &apos;render(): Target node has markup rendered by React, but there &apos; + &apos;are unrelated nodes as well. This is most commonly caused by &apos; + &apos;white-space inserted around server-rendered markup.&apos;) : void 0; break; &#125; rootElementSibling = rootElementSibling.nextSibling; &#125; &#125; &#125; var shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild; //加载到dom上 var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance(); if (callback) &#123; callback.call(component); &#125; return component;&#125;, 这段代码非常重要，render函数的功能全部再在此。 我们先来解析传入_renderSubtreeIntoContainer的参数： 参数 功能 parentComponent 当前组件的父组件，第一次渲染时为null nextElement 要插入DOM中的组件，如helloWorld container 要插入的容器，如document.getElementById(&#39;root&#39;) callback 完成后的回调函数 这几个参数的功能很好理解，接下来我们逐行进行逻辑分析： line 2：将当前组件添加到前一级的props属性下。(本文开头已说明父子嵌套关系由props提供) line 4 ~ 22：调用getTopLevelWrapperInContainer方法判断当前容器下是否存在组件，记为prevComponent；如果有即prevComponent为true，执行更新流程，即调用_updateRootComponent方法。若不存在，则卸载。(调用unmountComponentAtNode方法) line 24：不管是更新还是卸载，最终都要挂载到真实的DOM上。看下._renderNewRootComponent的源码：12345678910111213141516171819202122_renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) &#123; // Various parts of our code (such as ReactCompositeComponent&apos;s // _renderValidatedComponent) assume that calls to render aren&apos;t nested; // verify that that&apos;s the case. process.env.NODE_ENV !== &apos;production&apos; ? warning(ReactCurrentOwner.current == null, &apos;_renderNewRootComponent(): Render methods should be a pure function &apos; + &apos;of props and state; triggering nested component updates from &apos; + &apos;render is not allowed. If necessary, trigger nested updates in &apos; + &apos;componentDidUpdate. Check the render method of %s.&apos;, ReactCurrentOwner.current &amp;&amp; ReactCurrentOwner.current.getName() || &apos;ReactCompositeComponent&apos;) : void 0; !isValidContainer(container) ? process.env.NODE_ENV !== &apos;production&apos; ? invariant(false, &apos;_registerComponent(...): Target container is not a DOM element.&apos;) : _prodInvariant(&apos;37&apos;) : void 0; ReactBrowserEventEmitter.ensureScrollValueMonitoring(); var componentInstance = instantiateReactComponent(nextElement, false); // The initial render is synchronous but any updates that happen during // rendering, in componentWillMount or componentDidMount, will be batched // according to the current batching strategy. // 通过一个批处理的方式去处理MountComponentIntoNode方法 ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context); var wrapperID = componentInstance._instance.rootID; instancesByReactRootID[wrapperID] = componentInstance; return componentInstance;&#125;, 分析一下流程： 第3行出现了instantiateReactComponent包装方法，这个我们后面再说。 第5行中batchedMountComponentIntoNode以事务的形式调用mountComponentIntoNode(事务将专门拿出一篇文章来解析)，该方法返回组件对应的HTML，记为变量markup。而mountComponentIntoNode最终调用的是_mountImageIntoNode，看下源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970_mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) &#123; !isValidContainer(container) ? process.env.NODE_ENV !== &apos;production&apos; ? invariant(false, &apos;mountComponentIntoNode(...): Target container is not valid.&apos;) : _prodInvariant(&apos;41&apos;) : void 0; if (shouldReuseMarkup) &#123; var rootElement = getReactRootElementInContainer(container); if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) &#123; ReactDOMComponentTree.precacheNode(instance, rootElement); return; &#125; else &#123; var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME); rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME); var rootMarkup = rootElement.outerHTML; rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum); var normalizedMarkup = markup; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; // because rootMarkup is retrieved from the DOM, various normalizations // will have occurred which will not be present in `markup`. Here, // insert markup into a &lt;div&gt; or &lt;iframe&gt; depending on the container // type to perform the same normalizations before comparing. var normalizer; if (container.nodeType === ELEMENT_NODE_TYPE) &#123; normalizer = document.createElement(&apos;div&apos;); normalizer.innerHTML = markup; normalizedMarkup = normalizer.innerHTML; &#125; else &#123; normalizer = document.createElement(&apos;iframe&apos;); document.body.appendChild(normalizer); normalizer.contentDocument.write(markup); normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML; document.body.removeChild(normalizer); &#125; &#125; var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup); var difference = &apos; (client) &apos; + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + &apos;\n (server) &apos; + rootMarkup.substring(diffIndex - 20, diffIndex + 20); !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== &apos;production&apos; ? invariant(false, &apos;You\&apos;re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s&apos;, difference) : _prodInvariant(&apos;42&apos;, difference) : void 0; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; process.env.NODE_ENV !== &apos;production&apos; ? warning(false, &apos;React attempted to reuse markup in a container but the &apos; + &apos;checksum was invalid. This generally means that you are &apos; + &apos;using server rendering and the markup generated on the &apos; + &apos;server was not what the client was expecting. React injected &apos; + &apos;new markup to compensate which works but you have lost many &apos; + &apos;of the benefits of server rendering. Instead, figure out &apos; + &apos;why the markup being generated is different on the client &apos; + &apos;or server:\n%s&apos;, difference) : void 0; &#125; &#125; &#125; !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== &apos;production&apos; ? invariant(false, &apos;You\&apos;re trying to render a component to the document but you didn\&apos;t use server rendering. We can\&apos;t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.&apos;) : _prodInvariant(&apos;43&apos;) : void 0; if (transaction.useCreateElement) &#123; while (container.lastChild) &#123; container.removeChild(container.lastChild); &#125; DOMLazyTree.insertTreeBefore(container, markup, null); &#125; else &#123; //执行的主要是这行 setInnerHTML(container, markup); ReactDOMComponentTree.precacheNode(instance, container.firstChild); &#125; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild); if (hostNode._debugID !== 0) &#123; ReactInstrumentation.debugTool.onHostOperation(&#123; instanceID: hostNode._debugID, type: &apos;mount&apos;, payload: markup.toString() &#125;); &#125; &#125;&#125; 核心代码就是最后两行。setInnerHTML是一个方法，将markup设置为container的innerHTML属性，这样就完成了DOM的插入。precacheNode方法是将处理好的组件对象存储在缓存中，提高结构更新的速度。 React组件初始化和挂载的流程到这里基本明朗了。在ReactDOM.render()的方法使用中，我们会注意到该方法可以挂载React组件，也可以挂载字符串，也可以挂载原生DOM。现在我们已经知道，其实挂载就是利用innerHTML属性，但是对于不同的元素结构，React是否也有不同的处理呢？ 上文我们提到，在组件挂载的倒数第二步，也就是执行_renderNewRootComponent方法时，我们看到有一个名为instantiateReactComponent的方法返回一个经过加工的对象。我们看下instantiateReactComponent的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function instantiateReactComponent(node, shouldHaveDebugID) &#123; var instance; if (node === null || node === false) &#123; instance = ReactEmptyComponent.create(instantiateReactComponent); &#125; else if (typeof node === &apos;object&apos;) &#123; var element = node; var type = element.type; if (typeof type !== &apos;function&apos; &amp;&amp; typeof type !== &apos;string&apos;) &#123; var info = &apos;&apos;; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; if (type === undefined || typeof type === &apos;object&apos; &amp;&amp; type !== null &amp;&amp; Object.keys(type).length === 0) &#123; info += &apos; You likely forgot to export your component from the file &apos; + &quot;it&apos;s defined in.&quot;; &#125; &#125; info += getDeclarationErrorAddendum(element._owner); !false ? process.env.NODE_ENV !== &apos;production&apos; ? invariant(false, &apos;Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s&apos;, type == null ? type : typeof type, info) : _prodInvariant(&apos;130&apos;, type == null ? type : typeof type, info) : void 0; &#125; // Special case string values if (typeof element.type === &apos;string&apos;) &#123; instance = ReactHostComponent.createInternalComponent(element); &#125; else if (isInternalComponentType(element.type)) &#123; // This is temporarily available for custom components that are not string // representations. I.e. ART. Once those are updated to use the string // representation, we can drop this code path. instance = new element.type(element); // We renamed this. Allow the old name for compat. :( if (!instance.getHostNode) &#123; instance.getHostNode = instance.getNativeNode; &#125; &#125; else &#123; instance = new ReactCompositeComponentWrapper(element); &#125; &#125; else if (typeof node === &apos;string&apos; || typeof node === &apos;number&apos;) &#123; instance = ReactHostComponent.createInstanceForText(node); &#125; else &#123; !false ? process.env.NODE_ENV !== &apos;production&apos; ? invariant(false, &apos;Encountered invalid React node of type %s&apos;, typeof node) : _prodInvariant(&apos;131&apos;, typeof node) : void 0; &#125; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; process.env.NODE_ENV !== &apos;production&apos; ? warning(typeof instance.mountComponent === &apos;function&apos; &amp;&amp; typeof instance.receiveComponent === &apos;function&apos; &amp;&amp; typeof instance.getHostNode === &apos;function&apos; &amp;&amp; typeof instance.unmountComponent === &apos;function&apos;, &apos;Only React Components can be mounted.&apos;) : void 0; &#125; // These two fields are used by the DOM and ART diffing algorithms // respectively. Instead of using expandos on components, we should be // storing the state needed by the diffing algorithms elsewhere. instance._mountIndex = 0; instance._mountImage = null; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0; &#125; // Internal instances should fully constructed at this point, so they should // not get any new fields added to them at this point. if (process.env.NODE_ENV !== &apos;production&apos;) &#123; if (Object.preventExtensions) &#123; Object.preventExtensions(instance); &#125; &#125; return instance;&#125; 传入的参数node就是ReactDOM.render方法的组件参数，输入node和输出instance可以总结如下表： node 实际参数 结果 null/false 空 创建ReactEmptyComponent组件 object&amp;&amp;type === string 虚拟DOM 创建ReactDOMComponent组件 object&amp;&amp;type !== string React组件 创建ReactCompositeComponent组件 string 字符串 创建ReactTextComponent组件 number 数字 创建ReactTextComponent组件 梳理一下流程： 根据ReactDOM.render()传入不同的参数，React内部会创建四大类封装组件，记为componentInstance。 而后将其作为参数传入mountComponentIntoNode方法中，由此获得组件对应的HTML，记为变量markup。 将真实的DOM的属性innerHTML设置为markup，即完成了DOM插入。 那么问题来了，在上述第二步是如何解析出HTML的呢？答案是在第一步封装成四大类型组件的过程中，赋予了封装组件mountComponet方法， 执行该方法会触发组件的生命周期，从而解析出HTML。 当然，这四大类组件我们最常用的就是ReactCompositeComponent组件，也就是我们常说的React组件，其内部具有完整的生命周期，也是React最关键的组件特性。关于详细的组件类型与生命周期的部分，我们在下一篇文章讲解。 总结用一张图来梳理React组件从声明到初始化再到挂载的流程：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[低层次的学习者的4个坏习惯]]></title>
    <url>%2F2018%2F12%2F11%2FfourBadHabit%2F</url>
    <content type="text"><![CDATA[我当过学生，成绩好过，也差过。我当过老师，教出过好成绩的学生，也教出过差成绩的学生。相同的学习基础，经历一段时间的学习之后，为什么会产生差距呢？我一直在思考，一直在观察，最终我发现成绩不好的学生之所以不好，主要是因为身上存在一些不好的学习习惯。 坏习惯一：不思考自己为什么要学低层次的学习者，往往不会思考自己为什么要学？缺乏明确的学习目标，缺乏较强的学习动力，很多时候的学习都是“伪学习”，无效率的努力。看见别人在学，自己不学点怎么好意思呢？这是很多低层次学习者的状态。实质上，他们并没有把主要精力放在学习上，只不过是迫于周边“形式”，假装自己在学，好让自己的良心过得去一点。学习者，一定要明确自己为什么要学，只有明确自己为什么要学，才能有动力学，才能知道怎么学。 坏习惯二：不复盘自己的学习低层次的学习者，很少会复盘自己的学习。进步的时候，他们不会去复盘，不去总结自己进步的经验。退步或者止步的时候，也不会去复盘，不去总结自己不前进的原因。而是把这一切都归结于自己的脑子不行，默认现状，不思进取。可是事实真的是这样吗？你的成绩好的同学真的是天生就比你聪明吗？其实绝大多数情况并非如此，他们成绩好，一方面原因是因为他们懂得“复盘”。他们会思考总结自己的学习状况，做出评估。然后从“失败”中学习，考虑自己是否需要做调整，需要做什么调整。当然对于做得好的地方，他们也会去总结，去突破。他们将学习掌握在自己的手中，而不是上天赋予的头脑。很多时候，不是上天没有给予我们好头脑，只是你没去开启你的好头脑，难道不是吗？ 坏习惯三：多思考，懒于行动想法多于行动这是学习者致命的弱点。而对于低层次的学习者，大多是有这个习惯的，他们遇到事情总是想得多，做得少。比如，学习日语。有的同学对学日语很感兴趣，也很想学好。可是当他们真正想去学的时候，就变成了思想上的巨人、行动上的矮子。特别是遇到学习上的困难的时候。他们会花很多时间去思考怎么学好，而不是花时间直接去做。虽说“磨刀不误砍柴功”，但有时它也是误的，等你磨好了刀，柴都被别人砍完了，那又怎么办？何不边砍边磨呢？在“砍”的过程中，通过实践总结更好的砍柴经验呢？ 坏习惯四：流于表面，不去举一反三高层次的学习者和低层次的学习者最大的差别，其实不是够不够聪明，也不是够不够努力，而是认知深度不同。高层次的学习者喜欢了解问题的本质，了解事情的底层规律。就比如我们看简书上的文章，低层次的学习者的习惯可能就只是随便刷刷就算了，图一个新鲜，图一个愉快。而对于高层次的学习者，对于好的文章，他或她就可能去分析别人是怎么构思行文，可能去想如何去把别人在文中的经验用到自己的生活或工作中，可能去想如果是自己写这样的文章又会怎样写。思考，让他们有所得。而差距，也是在这一瞬间也被拉开。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 Express.js]]></title>
    <url>%2F2018%2F12%2F11%2FExpressKnowledge%2F</url>
    <content type="text"><![CDATA[本文针对那些对Node.js有一定了解的读者。假设你已经知道如何运行Node代码，使用npm安装依赖模块。但我保证，你并不需要是这方面的专家。本文针对的是Express 3.2.5版本，以介绍相关概念为主。 Express.js这么描述自己：”轻量灵活的node.js Web应用框架”。它可以帮助你快速搭建web应用。如果你使用过Ruby里的Sinatra,那么相信你对这个也会很快就能熟悉。 和其他web框架一样，Express隐藏了代码背后的祕密，然后告诉你：”别担心，你不用去理解这个部分”。它来帮你解决这些问题，所以你不用去为这个而烦恼，只用将重心集中到代码上。换句话说，它有某些魔法！ Express的wiki里介绍了一些它的使用者，其中就有很多知名的公司: MySpace, Klout. 但是拥有魔力是需要付出代价的，你可能根本就不知道它的工作原理。正如驾驶一辆汽车，我可以很好的驾驭它但是可能不理解为什么汽车可以正常工作，但是我最好知道这些东西。如果车坏掉怎么办？如果你想最大程度的去发挥它的性能？如果你对知识有无限的渴望并想去弄清它？ 那么我首先从理解Express的最底层-Node开始。 底层：Node HTTP服务器Node中有HTTP模块, 它将搭建一个web服务器的过程抽象出来。你可以这样使用: 1234567891011121314// 引入所需模块var http = require(&quot;http&quot;);// 建立服务器var app = http.createServer(function(request, response) &#123;response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);response.end(&quot;Hello world!\n&quot;);&#125;);// 启动服务器app.listen(1337, &quot;localhost&quot;);console.log(&quot;Server running at http://localhost:1337/&quot;); 运行这个程序(假设文件名为 app.js ,运行 node app.js )，你会得到”Hello world!“ 在浏览器访问localhost:1337 ，你会得到同样的结果。你也可以尝试访问其他地址，如 localhost:1337/whatever ，结果仍然会一样。 分解以上代码来看。 第一行使用 require 函数引入Node内置模块 http 。然后存入名为 http 的变量中。如果你要了解更多关于require函数的知识，参考Nodejitsu的文档。 然后我们使用 http.createServer 将服务器保存至 app 变量。它将一个函数作为参数监听请求。稍后将会详细介绍它。 最后我们要做的就是告诉服务器监听来自1337端口的请求，之后输出结果。然后一切完成。 好的，回到request请求处理函数。这个函数相当重要。 request方法 在开始这个部分之前，我事先声明这里所涉及的HTTP相关知识与学习Express本身没有太大关係。如果你感兴趣，可以查看HTTP模块文档。 任何时候我们向服务器发起请求，request方法将会被调用。如果你不信，你可以 console.log 将结果打印出来。你会发现每次请求一个页面时它都会出来。 request 是来自客户端的请求。在很多应用中，你可能会看到它的缩写 req 。仔细看代码。我们修改代码如下: 12345678910111213var app = http.createServer(function(request, response) &#123;// 创建answer变量var answer = &quot;&quot;;answer += &quot;Request URL: &quot; + request.url + &quot;\n&quot;;answer += &quot;Request type: &quot; + request.method + &quot;\n&quot;;answer += &quot;Request headers: &quot; + JSON.stringify(request.headers) + &quot;\n&quot;;// 返回结果response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);response.end(answer);&#125;); 重启服务器并刷新 localhsot:1337 .你会发现，每次访问一个URL，就会发起一次GET请求，并会得到一堆类似用户代理或者一些其他的更加複杂的HTTP相关信息。如果你访问 localhost:1337/what_is_fraser, 你会看到request的地址发生了变化。如果你使用不同的浏览器访问，用户代理也会跟着改变，如果你使用POST请求，request的方法也很改变。 response 是另外一个部分。正如 request 被缩写为 req ，response 同样被简写为 res 。每次response你都会得到对应的返回结果，之后你便可以通过调用 response.end 来结束。实际上最终你还是要执行这个方法的, 甚至在node的文档里也是这么描述的。这个方法完成了真正的数据传输部分。你可以建立一个服务器并不调用 req.end 方法，它就会永远存在。 在你返回结果之前，你也可以填写一下header头部部分。我们的例子里是这么写的: 1response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); 这个步骤主要完成两件事情。第一，发送HTTP状态码，表示请求成功。其次，它设置了返回的头部信息。这里表示我们要返回的是纯文本格式的内容。我们也可以返回类似JSON或者HTML格式的内容。 看了上面的之后，你可能会立马开始利用它来写api了。 1234567891011121314151617181920212223http = require(&quot;http&quot;);http.createServer(function(req, res) &#123;// Homepageif(req.url == &quot;/&quot;) &#123;res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;);res.end(&quot;Welcome to the homepage!&quot;);&#125;// About pageelse if (req.url == &quot;/about&quot;) &#123;res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;);res.end(&quot;Welcome to the about page!&quot;);&#125;// 404&apos;d!else &#123;res.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);res.end(&quot;404 error! File not found.&quot;);&#125;&#125;).listen(1337, &quot;localhost&quot;); 你可以选择优化代码，让它变得更整洁。也可以向npm.org的那帮傢伙一样用原生的Node来编写。但是你也可以选择去创建一个框架。这就是Sencha所做的，并把这个框架称为 – Connect. 中间件: ConnectConnect是Nodejs的中间件。可能你现在还并不太理解什么是中间件(middleware)，别担心，我马上会进行详细解释。 一段Connect代码 假如我们想要编写和上面一样的代码，但是这次我们要使用Connect.别忘记安装Connect模块(npm install)。完成之后，代码看起来非常相似。 123456789101112131415// 引入所需模塊var connect = require(&quot;connect&quot;);var http = require(&quot;http&quot;);// 建立appvar app = connect();// 添加中间件app.use(function(request, response) &#123;response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);response.end(&quot;Hello world!\n&quot;);&#125;);// 启动应用http.createServer(app).listen(1337); 下面分解这段代码来看。 首先我们分别引入了Connect和Node HTTP模块。 接下来和之前一样声明 app 变量，但是在创建服务器时，我们调用了 connect().这有是如何工作的？ 我们添加了一个中间件，实际上就是一个函数。传入 app.use ，几乎和上面使用request方法写法一样。实际上代码是从上面粘贴过来的。 之后我们建立并啓动服务器。 http.createServer 接收函数作为参数。没错，app 实际上也是一个函数。这是一个Connect提供的函数，它会查找代码并自上而下执行。 (你可能会看见其他人使用 app.listen(1337), 这实际上只是将 http.createServer 返回一个promise对象。 再Connect和Express中都是一样的原理。) 接下来解释什么是中间件(middleware). 什么是中间件? 首先推荐阅读Stephen Sugden对于Connect中间件的描述,比我讲的更好。如果你不喜欢我的解释，那就去看看。 还记得之前的request方法？每个中间件都是一个handler.依次传入request, response, next三个参数。 一个最基本的中间件结构如下: 12345function myFunMiddleware(request, response, next) &#123;// 对request和response作出相应操作// 操作完毕后返回next()即可转入下個中间件next();&#125; 当我们啓动一个服务器，函数开始从顶部一直往下执行。如果你想输出函数的执行过程，添加一下代码: 1234567891011121314151617var connect = require(&quot;connect&quot;);var http = require(&quot;http&quot;);var app = connect();// log中间件app.use(function(request, response, next) &#123;console.log(&quot;In comes a &quot; + request.method + &quot; to &quot; + request.url);next();&#125;);// 返回&quot;hello world&quot;app.use(function(request, response, next) &#123;response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);response.end(&quot;Hello World!\n&quot;);&#125;);http.createServer(app).listen(1337); 如果你啓动应用并访问 localhost:1337，你会看到服务器可以log出相关信息。 有一点值得注意，任何可以在Node.js下执行的代码都可以在中间件执行。例如上面我们所使用的req.method 方法。 你当然可以编写自己的中间件，但是也不要错过Connect的一些很cool的第三方中间件。下面我们移除自己的log中间件，使用Connect内置方法。 12345678910111213var connect = require(&quot;connect&quot;);var http = require(&quot;http&quot;);var app = connect();app.use(connect.logger());// 一個有趣的事实：connect.logger返回一個函数app.use(function(request, response) &#123;response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);response.end(&quot;Hello world!\n&quot;);&#125;);http.createServer(app).listen(1337); 跳转至浏览器并访问 localhost:1337 你会得到同样的结果。 很快有人就会想使用上面的中间件组合起来创建一个完整应用。代码如下: 1234567891011121314151617181920212223242526272829303132333435var connect = require(&quot;connect&quot;);var http = require(&quot;http&quot;);var app = connect();app.use(connect.logger());// Homepageapp.use(function(request, response, next) &#123;if (request.url == &quot;/&quot;) &#123;response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);response.end(&quot;Welcome to the homepage!\n&quot;);// The middleware stops here.&#125; else &#123;next();&#125;&#125;);// About pageapp.use(function(request, response, next) &#123;if (request.url == &quot;/about&quot;) &#123;response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);response.end(&quot;Welcome to the about page!\n&quot;);// The middleware stops here.&#125; else &#123;next();&#125;&#125;);// 404&apos;d!app.use(function(request, response) &#123;response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);response.end(&quot;404 error!\n&quot;);&#125;);http.createServer(app).listen(1337); “这个看起来不太好看!我要自己写框架！” 某些人看了Connect的代码之后觉得，“这个代码可以更简单”。于是他们创造了Express.（事实上他们好像直接盗用了Sinatra.） 最顶层: Express文章进入第三部分，我们开始真正进入Express. 正如Connect拓展了Node, Express拓展Connect.代码的开始部分看起来和在Connect中非常类似： 123var express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express(); 结尾部分也一样: 1http.createServer(app).listen(1337); 中间部分纔是不一样的地方。Connect为我们提供了中间件，Express则为我们提供了另外三个优秀的特性： 路由分发，请求处理，视图渲染。首先从如有开始看。 特性一：路由路由的功能就是处理不同的请求。在上面的很多例子中，我们分别有首页，关于和404页面。我们是通过 if 来判断并处理不同请求地址。 但是Express却可以做的更好。Express提供了”routing”这个东西，也就是我们所说的路由。我觉得可读性甚至比纯文字还要好。 12345678910111213141516171819202122var express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.all(&quot;*&quot;, function(request, response, next) &#123;response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);next();&#125;);app.get(&quot;/&quot;, function(request, response) &#123;response.end(&quot;Welcome to the homepage!&quot;);&#125;);app.get(&quot;/about&quot;, function(request, response) &#123;response.end(&quot;Welcome to the about page!&quot;);&#125;);app.get(&quot;*&quot;, function(request, response) &#123;response.end(&quot;404!&quot;);&#125;);http.createServer(app).listen(1337); 简单的引入相关模块之后，我们立即调用 app.all处理所有请求。写法看起来也非常像中间件不是吗？ 代码中的 app.get 就是Express提供的路由系统。也可以是 app.post 来处理POST请求，或者是PUT和任何的HTTP请求方式。第一个参数是路径，例如 /about 或者 /。第二个参数类似我们之前所见过的请求handler。引用Expess文档的内容: 这些请求handler和中间件一样，唯一的区别是这些回调函数会调用 next(‘route’) 从而能够继续执行剩下的路由回调函数。这种机制简单说来，它们和我们之前提过的中间件是一样，只不过是一些函数而已。 这些路由也可以更加灵活，看起来是这样： 123app.get(&quot;/hello/:who&quot;, function(req, res) &#123;res.end(&quot;Hello, &quot; + req.params.who + &quot;.&quot;); &#125;); 重启服务器并在浏览器访问 localhost:1337/hello/animelover69 你会得到如下信息： 1&lt;code&gt;Hello, animelover69. &lt;/code&gt; 这些文档演示了如何使用正则表达式，可以使得路由更加灵活。如果只是单从概念理解来讲，我说的已经足够了。 但是还有更加值得我们去关注的。 特性二：请求处理 request handlingExpress将你传入请求的handler传入request和response对象中。原先该有的还在，但是却加入了更多新的特性。API文档里有详细解释。下面让我们来看一些例子。 其中一个就是 redirect 方法。代码如下： 123response.redirect(&quot;/hello/anime&quot;);response.redirect(&quot;http://xvfeng.me&quot;);response.redirect(301, &quot;http://xvfeng.me&quot;); // HTTP 301状态码 以上代码既不属于原生Node代码也不是来自与Connect,而是Express中自身添加的。它加入了一些例如sendFile，让你传输整个文件等功能： 1response.sendFile(&quot;/path/to/anime.mp4&quot;); request对象还有一些很cool的属性，例如 request.ip 可以获取IP地址, request.files 上传文件等。 理论上来讲，我们要知道的东西也不是太多，Express做的只是拓展了request和response对象而已。Express所提供的方法，请参考API文档. 特性三：视图Express可以渲染视图。代码如下： 123456789// 启动Expressvar express = require(&quot;express&quot;);var app = express();// 設置view目錄app.set(&quot;views&quot;, __dirname + &quot;/views&quot;);// 設置模板引擎app.set(&quot;view engine&quot;, &quot;jade&quot;); 开头部分的代码和前面基本一样。之后我们指定视图文件所在目录。然后告诉Express我们要使用 Jade作为模板引擎。 Jade是一种模板语言。稍后将会详细介绍。 现在我们已经设置好了view.但是如何来使用它呢？ 首先我们建立一个名为 index.jade 的文件并把它放入 views 目录。代码如下： 12345doctype 5htmlbodyh1 Hello, world!p= message 代码只是去掉了括号的HTML代码。如果你懂HTML那肯定也看得懂上面的代码。唯一有趣的是最后一样。 message 是一个变量。它是从哪里来的呢？马上告诉你。 我们需要从Express中渲染这个视图。代码如下： 123app.get(&quot;/&quot;, function(request, response) &#123;response.render(&quot;index&quot;, &#123; message: &quot;I love anime&quot; &#125;); &#125;); Express为 response 对象添加了一个 render 方法。这个方法可以处理很多事情，但最主要的还是加载模板引擎和对应的视图文件，之后渲染成普通的HTML文档，例如这里的 index.jade. 最后一步(我觉得可能算是第一步)就是安装Jade,因为它本身并不是Express的一部分。添加至package.json 文件并使用 npm install 进行安装。 如果一起设置完毕，你会看到这个页面。完整代码. 加分特性： 所有代码来自于Connect和Node我需要再次提醒你的是Express建立与Connect和Node之上，这意味着所有的Connect中间件均可以在Express中使用。这个对与开发来讲帮助很大。例如： 12345678910var express = require(&quot;express&quot;);var app = express();app.use(express.logger()); // 继承自Connectapp.get(&quot;/&quot;, function(req, res) &#123;res.send(&quot;fraser&quot;); &#125;);app.listen(1337); 如果说你从这篇文章中学到了一点什么，就是这一点。 实战本文的大部分内容都是理论，但是下面我将教你如何使用它来做一点你想做的东西。我不想说的过于具体。 你可以将Express安装到系统全局，从而可以在命令行使用它。它可以帮助你迅速的完成代码组织并啓动应用。使用npm安装： 1&lt;code&gt;# 安装时可能需要加 `sudo` npm install -g express &lt;/code&gt; 如果你需要帮助，输入 express –help 。它加入一些可选参数。例如，如果你想使用EJS模板引擎，LESS作为CSS引擎。应用的名称为”myApp”.输入以下命令： 1&lt;code&gt;express --ejs --css less myApp &lt;/code&gt; 这里会自动生成很多文件。进入项目目录，并使用 npm install 安装依赖包，之后便可以使用 node app啓动应用！我建议你详细的查看项目结构和代码。它可能还算不上一个真正的应用，但是我觉得它对于初学者来讲还是很有帮助的。 项目Github目录下也有一些很有帮助的文档。 一些补充 如果你也和我一样喜欢使用CoffeeScript，好消息是Express完美支持CoffeeScript.你甚至不需要编译它。这样你只用 coffee app.coffee 即可啓动应用。我在我的其他项目中也是这么做的。 在我看到 app.use(app.router) 的时候我很疑惑： Express不是一直在使用router吗？简单回答是app.router 是Express的路由中间件，在你定义路由的时候被直接添加到项目中。如果你需要在加载其他文件之前应用，也可以直接引入它。关于这么做的原因，请参考StackOverflow的这个答桉. 本文是针对Express 3，而在第四版的规划中又会有很多大的改动。最明显的是，Experss可能要将会分解成一些小的模块，并吸收Connect的一些特性。这个虽然还在计划中，但是也值得一看。如果这个还不能满足你？你肯定是个变态！你很快就会变成像一个瘾君子，半睁着眼，耗尽你最后一点精力，写着苦逼的代码。 正如Rails成为使用Ruby建立网页应用的王者一样，我觉得Express也会成为Node中的主流。但是和Rails不一样，Express更加底层。似乎还没有一个真正意义上的高级Node库。我觉得可能会发生改变。（译者注：这点我不同意，Node的很多思想来自与Unix哲学，强调的是一个Module只解决一个问题，而不是成为一个複杂的库。很多Rails的开发者转向Node，就是因为Rails正在逐渐变得臃肿，不易自定义，且效率逐渐降低。）。 这里我就不再多谈。已经又很多很基于Express建立了新的东西，Expess的维基里有列举。如果你觉得好可以随意使用它们，如果你喜欢从底层做起，你也可以只选择Express。不管是哪一种，好好利用它吧。 参考 深入理解Express.js]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry框架的整合和使用]]></title>
    <url>%2F2018%2F12%2F10%2FmasonryUse%2F</url>
    <content type="text"><![CDATA[准备工作CocoaPods简介CocoaPods是一个用于管理iOS开发中用到的第三方开源库的插件，CocoaPods能所提供的功能是搜索，下载和更新在git hub上的iOS相关第三方开源库，是iOS中最常用也是最有名的类库管理工具了 CocoaPods安装因为macOS新版本中已经安装好了Ruby环境，那么安装CocoaPods只需要一行代码：sudo gem install cocoapods (需要翻墙的)，成功之后使用pod setup来进行安装(非常慢)，所以我们换一个办法，先cd到cd ~/.cocoapods/repos，然后使用git clone https://github.com/CocoaPods/Specs.git，把github上的CocoaPods的内容赋值到repos文件夹底下，然后到finder中command+shift+G打开路径输入，到repos文件夹里把这个Specs文件夹重命名为master即完成了CocoaPods的安装 安装Masonry框架之后cd到工程目录底下，创建一个Podfile文件，这个文件是第三方类库文件的总管，用它可以管理该工程内的所有第三方类库，可以进行更新，删除，和批量下载，创建好之后vi Podfile打开，在里面首先写入工程部署的iOS最低版本号，比如platform :ios,’8.0’，然后写入target，以及针对这个target引入的第三方类，比如12345platform : ios,&apos;8.0&apos;target &apos;SayWhere&apos; do pod &apos;ReactiveCocoa&apos;, &apos;2.5&apos; pod &apos;Masonry&apos;end esc退出编辑：wq保存退出，然后用pod install即可。Pod的命令很多，常见的比如pod search Masonry ，可以搜索关键字相对应的所有在github上有的第三方类库，搜索结果会给出如何导入，和所有版本号，十分的方便。 使用框架Masonry简介Masonry又叫自适应布局，他所实现的功能其实非常简单，就是定义一个view，在它的上层view，或者平行view，或者下层view的位置，通过添加约束的方法进行实现。约束有几种，分别是边距，宽，高，左上右下距离，基准线，添加过约束之后可以进行修正，修正有offset（位移）和multipliedBy（倍率）修正。 Masonry如何引入在需要使用的地方引入头文件 #import “Masonry.h”位移和倍率修正语法一般是 make.equalTo or make.greaterThanOrEqualTo or make.lessThanOrEqualTo + 倍数和位移修正。 注意点1： 使用 mas_makeConstraints方法的元素必须事先添加到父元素的中，例如[self.view addSubview:view];注意点2： masequalTo 和 equalTo 区别：masequalTo 比equalTo多了类型转换操作，一般来说，大多数时候两个方法都是 通用的，但是对于数值元素使用mas_equalTo。对于对象或是多个属性的处理，使用equalTo。特别是多个属性时，必须使用equalTo,例如 make.left.and.right.equalTo(self.view);注意点3: 注意到方法with和and,这连个方法其实没有做任何操作，方法只是返回对象本身，这这个方法的左右完全是为了方法写的时候的可读性 。make.left.and.right.equalTo(self.view);和make.left.right.equalTo(self.view);是完全一样的，但是明显的加了and方法的语句可读性 更好点。结合了Masonry的工程里的约束写起来一般是这样的123456[bgView ms_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self).offset(0); make.right.equalTo(self).offset(0); make.top.equalTo(self).offset(0); make.bottom.equalTo(self).offset(0);&#125;] 三个核心的方法添加约束12- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;&#125; 更新约束12- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *))block &#123;&#125; 重写约束12- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block &#123;&#125; 如何更简便的使用Masonry两个很重要的宏：我们刚接触Masonry的时候可能对于什么时候写mas什么时候需要传递NSNumber对象比较糊涂框架的作者也考虑到了这个问题为我们提供了两个宏解决了上面的问题只要把这个两个宏复制到项目里就完美解决12//define this constant if you want to use Masonry without the &apos;mas_&apos; prefix#define MAS_SHORTHAND 12//define this constant if you want to enable auto-boxing for default syntax#define MAS_SHORTHAND_GLOBALS]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven-SpringMVC工程]]></title>
    <url>%2F2018%2F12%2F10%2FnewMavenSpring%2F</url>
    <content type="text"><![CDATA[新建一个Maven-Spring工程下载eclipse-Spring插件 新建一个SpringLagacyProject 添进各种依赖jar包jackson的jar包，用于解析json文档123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt; spring-web,spring-oxm和spring-context123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 设置取消静态资源的过滤在mvc-config中添加进如下代码：12345&lt;!-- Spring框架静态资源的处理，mapping实在地址栏上访问的路径，location对应资源的物理路径 --&gt;&lt;mvc:resources location="/js/" mapping="/js/**" /&gt;&lt;mvc:resources location="/css/" mapping="/css/**" /&gt;&lt;mvc:resources location="/images/" mapping="/images/**" /&gt;&lt;mvc:resources location="/html/" mapping="/html/**" /&gt; 设置相应字符串的编码123456789&lt;!-- 设置相应字符串编码 --&gt;&lt;bean id="stringConverter" class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 配置json的存取12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 用于将对象转换为 JSON --&gt;&lt;bean id="jsonConverter" class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter" /&gt;&lt;!-- Message文件转换器 --&gt;&lt;beanclass="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="stringConverter" /&gt; &lt;ref bean="jsonConverter" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- date的解析 --&gt;&lt;bean id="conversion-service" class="org.springframework.format.support.FormattingConversionServiceFactoryBean" /&gt;&lt;!-- ContentNegotiatingViewResolver视图解析器,利用他就可以配置多种返回值 --&gt;&lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;!-- 这里是否忽略掉accept header，默认就是false --&gt; &lt;property name="ignoreAcceptHeader" value="true" /&gt; &lt;!-- 如果所有的mediaType都没匹配上，就会使用defaultContentType --&gt; &lt;property name="defaultContentType" value="text/html" /&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 默认使用MappingJacksonJsonView生成jsonview --&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"&gt; &lt;property name="extractValueFromSingleKeyModel" value="true" /&gt; &lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.view.xml.MarshallingView"&gt; &lt;property name="marshaller"&gt; &lt;bean class="org.springframework.oxm.xstream.XStreamMarshaller" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 配置一个带json输出的helloworld在新建一个Control类中写上@control表示为控制层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*** Copyright (c) 2000-2011 杭州天丽科技有限公司* All rights reserved.** spring 1.00 ** Date Author Changes Remark* 2016年3月1日 WangLifeng Created 创建*/package com.springspringspring.controller;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import org.springframework.beans.propertyeditors.CustomDateEditor;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.ServletRequestDataBinder;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import com.springspringspring.model.Student;/*** Class description goes here.** @date 2016.3.1* @verison 1.00 * @author WangLifeng* @see*/@Controllerpublic class HelloControl &#123;@RequestMapping(value="/xml",method=RequestMethod.GET)@ResponseBody public ModelAndView xml(Model model)&#123; Map&lt;String, Object&gt; map=new HashMap&lt;String, Object&gt;(); Student stu=new Student(); stu.setId(1232); map.put("asdfasdfd", "asdfsdf"); map.put("student", stu); List list=new ArrayList&lt;String&gt;(); list.add("asdfasdf"); list.add("sdasd"); ModelAndView model2=new ModelAndView("showMessage",map); return model2; &#125; // At the time of initialization,convert the type "String" to type "date" @InitBinder public void initBinder(ServletRequestDataBinder binder)&#123; binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"),true)); &#125;&#125; 新建一个jsp页面来进行显示在WEB-INF的view文件夹下面加一个showMessage.jsp并加入以下代码12345678910111213&lt;!DOCTYPE html&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Welcome&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;$&#123;message&#125;&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; 将工程配置到tomcat上并查看结果右键工程，run as Maven Build，中的运行参数中写tomcat7:run]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建并配置Maven工程]]></title>
    <url>%2F2018%2F12%2F10%2FnewMavenProject%2F</url>
    <content type="text"><![CDATA[建立一个maven工程新建工程中搜索Maven，选择Maven Project 在Archetype中选择maven-archetype-webapp选项，创建web app 填入工程相关信息 在Pom.xml的标签中添加tomcat其中的spring替换为你的工程名1234567891011121314&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/spring&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;finalName&gt;spring&lt;/finalName&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; index.jsp报错，因为没添加一些jar包，这里补上添加上jar包依赖部分12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0-alpha-1&lt;/version&gt;&lt;/dependency&gt; 至此，应该形成一个没有报错的有图标的Maven工程]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue页面动态添加Html标签中如何绑定事件]]></title>
    <url>%2F2018%2F12%2F10%2FVueIntoHtml%2F</url>
    <content type="text"><![CDATA[问题的背景：说一说近期碰到的一个困扰我很久的问题吧：问题是在编写一个vue2.0+easyUI的页面的时候出现的。 easyUI的图表，在Vue中的展示就像这样的一张图表，需求很简单，就是每一行最右边的操作栏都有一个按键，可以操作单行的数据 问题的出现：超简单！往里面放一个按钮不就可以了吗！于是，我试图着手在这一行里放入一个按钮，但一看代码，Oh my god！123456789101112// 表数据tableObj.data=[];if(dataList.length&gt;0) &#123; for(vari=0; i&lt;dataList.length; i++) &#123; var subData=&#123; &quot;userId&quot;:dataList[i].id, &quot;userName&quot;:dataList[i].value, &quot;operate&quot;:getOperateHtml(i), &#125;; tableObj.data.push(subData); &#125;&#125; 这每一行一行的，居然全部都是只允许往里面放字符串的！！好吧，那怎么办呢，简单！把控件写成字符串放进去就可以了啊，于是，我写出了上面的operate字段中的getOperateHtml方法123functiongetOperateHtml(id) &#123; var operateHtml = &apos;&lt;a onclick=&quot;turnToUserEdit(\&apos;&apos;+id+&apos;\&apos;)&quot;&apos;+&quot;id=&apos;editUserBtn&apos; style=&apos;color:#07bb49;display:none;&apos;class=&apos;editUserBtn&apos;&gt;编辑&quot;&lt;/a&gt;&quot;;return operateHtml; easy!这样的话，我在下面补上一个turnToUserEdit(id)方法不就ok了么！！ 就在这里，问题出现了，直接在下面接一个function是无法调用到的，而如果把方法写在window里面的话，又没有办法获取到当前vue的this对象，只能用router做一个跳转，无法操作当前vue的对象里的数组变量。123window.turnToUserEdit=function(id)&#123; router.push(&#123; path:&apos;/userAddOrEdit&apos;,query:&#123;userId:id&#125;&#125;);&#125; 这可如何是好，这让刚接触vue的我慌了神 问题的剖析：这个问题，在逻辑上来说应该是很好理解的，出现这个问题，也是无比正常的 在我的理解中，对vue代码的理解，需要分为编译前和编译后，用动态添加Html标签的方法，实际上就是在编译后添加进这个html语句，再生成这个控件，这时候在控件里写的onclick就是去找编译后的叫这个名称的方法，而直接写function的话，就生成的是编译前的方法，生成html之后在去找这个方法，必然是找不到的，找到的只能是后面写在window.function的全局方法，这个情况就像是下图 a标签的编译前后示意图那么，调用到了window.EditUser方法，那必然是拿不到当前vue的this指针的，因为编译后等于是把各个vue都混在了一起，谁分得清楚你和我呢！ 问题的解决：那么不影响大架构的情况下该如何解决这个问题呢，参考了segmentFault和stackOverflow上的一些意见，大致的意思是，这个地方，要建一个vue（带方法的）再给他编译一下，然后塞到这个按钮里，怎么塞进按钮里呢，就是编译完之后，找到我们之前放的这个a标签的节点，给它append一个child，放进我们的这个vue，这样事件就可以自定义，而且能获取到当前的对象啦！具体的写法的话大致是这样哒！12345678910varMyComponent=Vue.extend(&#123; template: &apos;&lt;a style=&quot;color:#07bb49;&quot; v-on:click=&quot;world(&apos;+&quot;&apos;&quot;+id+&quot;&apos;&quot;+&apos;)&quot;&gt;删除&lt;/a&gt;&apos;, methods:&#123; world:function(id) &#123; (this.data); &#125; &#125;&#125;);varcomponent= newMyComponent().$mount();document.getElementById(&apos;edituser&apos;).appendChild(component.$el); 至于第几行什么的，在这个edituser的a标签的id后面追加一个行号就可以了。 至此，事件圆满解决啦~ 稍微总结一下：出现这个现象的主要问题在vue的编译前和编译后不同的这个特性中，个人觉得，如果可以，还是应该尽量的去避免动态添加html标签，easyUI这个写法比较特殊，也可能有其他的控件有这种特殊的要求，在一般的操作中，还是使用v-的标签来进行显示的选择比较好]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自带相机顶部导航栏隐藏无效问题]]></title>
    <url>%2F2018%2F12%2F10%2FiOSCameraTop%2F</url>
    <content type="text"><![CDATA[问题背景构建了一个APP，因为导航栏样式全部统一，就为UIViewController写了一个分类，在所有的控制器中都引用这个分类，在分类中，动态的定义了一个变量，用Method Swizzling替换viewWillAppear方法指向我们的方法，在这里给VC们都统一按规则设置了状态栏和导航栏的样式。 问题出现于是有一天，产品经理提了一个需求，需要拍照上传一个东西，很顺手就来了一个UIImagePickerController 给新的VC设上自定义属性设好了autoNavigationBarHidden，字面意思，写的功能也就是自动隐藏导航栏，但是实际效果仍然是导航栏出现，看不见背后的闪光灯开关。 导航栏依然存在 问题分析这会是什么原因呢，难道是之前设置的无效了还是顶上覆盖的这层不是导航栏呢。不管怎样，先看看界面层级具体是个什么情况 界面层级￼看了一眼层级，哦，原来不仅仅是￼￼UIImagePickerController，这个上面还覆盖着CAMViewfinderViewController，CAMPreviewViewController好几个VC，他们具体是什么呢？在钩子函数中打印一下看看吧 新建一个UIImagePickerController时会弹出的VC 问题解决知道了这些VC的类名，只需要在钩子函数里根据类名判断一下，以后取照片就再也不会看到有导航栏的出现了。 根据类名进行判断 问题延伸问题比较简单，还好是使用了runtime的特性，为所有子VC都执行了方法，也很准确的发现了剩余的这些VC，如果仅仅是去设置UIImagePickerController的navigationBarHidden属性的话，可真是一时半会发现不了这个问题了，这里也是mark一下，这次的解决也是一种思路。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 使用Upload插件上传读取文件内容]]></title>
    <url>%2F2018%2F12%2F10%2FreactUpload%2F</url>
    <content type="text"><![CDATA[问题背景某一天，公司里需要一个功能，一个可以把一份参数多如牛毛的配置文件本地存储下来，本地也可以把文件读取出来这样便利的功能。分析一下这个需求，主要就是要以json的格式，保存，和web页面读取json文件的这样两个功能。公司的工程是react编写的，可能对vue和原生js都有一定了解的你，对react并不熟悉，那么，如何解决这个问题 分步解决一、保存JSON格式的文件首先，我们假定拿到了一个json格式的变量1var jsonData; 那么，再写一个download的工具类1234567891011121314151617/* * 下载文件* */function download(content, filename) &#123;// 创建隐藏的可下载链接var eleLink = document.createElement(&apos;a&apos;);eleLink.download = filename;eleLink.style.display = &apos;none&apos;;// 字符内容转变成blob地址var blob = new Blob([content]);eleLink.href = URL.createObjectURL(blob);// 触发点击document.body.appendChild(eleLink);eleLink.click();// 然后移除document.body.removeChild(eleLink);&#125; 发现问题！直接download下来的是没有格式化过的文本，乱成一团，毫无可读性可言。一个formatjson非常重要！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 格式化json文件，便于json文件的下载* */function formatJson(json, options) &#123; var reg = null, formatted = &apos;&apos;, pad = 0, PADDING = &apos; &apos;; options = options || &#123;&#125;; options.newlineAfterColonIfBeforeBraceOrBracket = (options.newlineAfterColonIfBeforeBraceOrBracket === true) ? true : false; options.spaceAfterColon = (options.spaceAfterColon === false) ? false : true; if (typeof json !== &apos;string&apos;) &#123; json = JSON.stringify(json); &#125; else &#123; json = JSON.parse(json); json = JSON.stringify(json); &#125; reg = /([\&#123;\&#125;])/g; json = json.replace(reg, &apos;\r\n$1\r\n&apos;); reg = /([\[\]])/g; json = json.replace(reg, &apos;\r\n$1\r\n&apos;); reg = /(\,)/g; json = json.replace(reg, &apos;$1\r\n&apos;); reg = /(\r\n\r\n)/g; json = json.replace(reg, &apos;\r\n&apos;); reg = /\r\n\,/g; json = json.replace(reg, &apos;,&apos;); if (!options.newlineAfterColonIfBeforeBraceOrBracket) &#123; reg = /\:\r\n\&#123;/g; json = json.replace(reg, &apos;:&#123;&apos;); reg = /\:\r\n\[/g; json = json.replace(reg, &apos;:[&apos;); &#125; if (options.spaceAfterColon) &#123; reg = /\:/g; json = json.replace(reg, &apos;:&apos;); &#125; (json.split(&apos;\r\n&apos;)).forEach(function (node, index) &#123; var i = 0, indent = 0, padding = &apos;&apos;; if (node.match(/\&#123;$/) || node.match(/\[$/)) &#123; indent = 1; &#125; else if (node.match(/\&#125;/) || node.match(/\]/)) &#123; if (pad !== 0) &#123; pad -= 1; &#125; &#125; else &#123; indent = 0; &#125; for (i = 0; i &lt; pad; i++) &#123; padding += PADDING; &#125; formatted += padding + node + &apos;\r\n&apos;; pad += indent; &#125;); return formatted; &#125; 一行调用！1download(formatJson(jsonData), &quot;configuration.json&quot;); 二、读取JSON格式的文件react有很多轮子，upload当然也有相应封装好的工具，引入！（在这之前别忘了npm install react-fileupload -save）1import FileUpload from &apos;react-fileupload&apos; 写一份配置文件，这个文件中写出的API这边有https://www.jianshu.com/p/3aa9d5ad41b012345678910111213this.options = &#123; baseUrl: &apos;https://jsonplaceholder.typicode.com/posts/&apos;, param: &#123; _c: &apos;file&apos;, _a: &apos;UploadFile&apos; &#125;, chooseFile: this.chooseFile, doUpload: this.do_upload, uploading: (progress) =&gt; &#123; this.uploading(progress); &#125;, uploadSuccess: this.upload_success, uploadError: this.upload_error, uploadFail: this.upload_fail,&#125; 操作在那边已经很清晰啦，我就不多说了1234&lt;FileUpload options=&#123;this.options&#125;&gt; &lt;button ref="chooseBtn"&gt;Chose file&lt;/button&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button ref="uploadBtn"&gt;upload&lt;/button&gt;&lt;/FileUpload&gt; 拿到文件之后，当然要把文件内容在web上就解析出来1234567var self = this;var reader = new FileReader();reader.readAsText(files[0]);reader.onload = function () &#123; console.log($.parseJSON(reader.result)); var fileContent = $.parseJSON(reader.result)&#125; 好啦，fileContent就是里面的内容，json对象，拿到之后，就可以为所欲为了！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用于前端开发的webpack4配置]]></title>
    <url>%2F2018%2F12%2F10%2FwebpackConfig%2F</url>
    <content type="text"><![CDATA[随着web开发变得越来越复杂，我们需要使用工具来帮助我们构建现代化网站。这是一个完整通过复杂webpack4配置的线上生产例子。构建现代化网站已经成为自定义应用程序开发，网站期望能做的更多，具有传统应用的功能，而不仅仅是一个推广网站。 随着一个流程变得复杂时，我们就会将它分解为可管理的组件，并使用工具进行自动化构建，比如制造汽车、起草法案[法律文件]、建立网站。1使用正确的工具完成工作 像webpack这样的工具一直处于现代web开发的最前沿，正是因为如此，它帮助我们构建复杂的事物。 webpack4拥有一些意想不到的改进，最吸引我的就是它在构建速度上面变得有多快，所以我决定采用它。hold住，因为这是一篇充满大量信息的长篇文章。 采用webpack一年多以前，我发表了一篇文章： A Gulp Workflow for Frontend Development Automation [用于前端自动化的gulp工作流]，讲解了如何使用gulp完成同样的事情。然而在这段时间里，我越来越多地使用像Vue-JS 和GraphQL 这样的前端框架，如Using VueJS + GraphQL to make Practical Magic 这篇文章。我发现webpack让我更容易的去构建各种类型的网站以及应用程序，而且它也允许我使用最现代化的工具链。还有其他选择： Laravel Mix是基于webpack的构建工具层，它十分简洁，你可以快速启动并运行，它可以在90%的时间内完成你想要的任务，但剩下的10%无论如何都会进入到webpack，目前还不支持webpack4。 如果你只是用VueJS前端框架，那么使用vue-cli是个不错的选择，它也是基于webpack，大部分时间都可以工作，并且为你做一些意想不到的事情。但同样的，当它提供的功能已经满足不了你的需求，你还是需要用到webpack，而且我并不是只使用VueJS。 Neutrino也是基于webpack，我们可以关注博客：Neutrino: How I Learned to Stop Worrying and Love Webpack。神奇的点就是它可以通过像搭乐高积木一样去配置webpack，但学习使用让的成本跟学习webpack其实差不了多少。 如果你选择上述工具（或者其他工具），我不会对你提出任何意见：它们都是基于webpack封装。1理解开发系统中层是如何工作的是有好处的。 最终，你只需要决定你希望站在前端技术金字塔中的哪个位置。某些时候，我认为了解像webpack这样重要的工具是如何工作是有意义的。不久前，我向Sean Larkin（webpack核心团队成员之一）抱怨说webpack就像一个“黑匣子”，他的回答简洁却非常精辟：1It’s only black if you haven’t opened it.[如果你没有打开这个所谓的“黑匣子”，它永远都是未知的。] 他说的对，是时候打开“黑匣子”了。本文不会教你所有关于webpack的知识，甚至是如何安装它，下面有很多、资料给你选择，你可以选择你认为不错的方式： webpack—the Confusing Parts ——简要概述了webpack的工作原理。 webpack documentation —— 建议读webpack官方文档，如果你想学好它的话 webpack fundamentals —— webpack教学视频 How to switch from Gulp to webpack 这样的资料还有很多，相反地本文将用webpack4配置一个复杂的完整工作例子，并添加注释。你可以使用完整的示例，也可以使用它的部分配置项，但希望你可以从中学到一些东西。在我学习webpack的过程中，我发现有很多教程视频，一堆文章给你将如何安装它并添加一些基础配置，但却大部分没有实际线上生产环境的webpack配置示例，所以我写了这篇文章。 WHAT WE GET OUT OF THE BOX 当我开始通过打开“黑匣子”来学习webpack时，我有一份我依赖的技术列表，我想将它成为构建流程的一部分。我也会花时间四处看看，看看在这个过程中，我还能采用什么。 正如在文章 A Pretty Website Isn’t Enough article讨论的那样，网站性能一直都是我关注的重点，所以在配置webpack过程中关注性能问题也很正常。 所以这是我想用webpack为我处理的事情，以及我希望在构建过程中加入的技术： Development / Production —— 在本地开发中，我通过webpack-dev-server进行快速构建，对于生产环境的构建（通常通过buddy.works在Docker容器中构建），我希望尽可能优化每一个点。因此，我们区分dev和prod的配置以及构建。 Hot Module Replacement —— 当我修改了js、css或者页面，我希望网页能够自动刷新，大幅度提高了开发效率：不需要你去点浏览器刷新按钮。 Dynamic Code Splitting —— 我不想手动在配置文件中定义js chunk，所以我让webpack帮我解决这个问题。 Lazy Loading —— 又称异步动态模块加载，在需要时加载所需的代码资源。 Modern &amp; Legacy JS Bundles —— 我想将es2015 + JavaScript模块发布到能够支持全球75%以上的浏览器上，同时为低版本的浏览器提供一个补丁包（包括所有转码和polyfills）。 Cache Busting via manifest.json —— 可以让我们为静态资源设置缓存，同时保证它们在更改使自动重新缓存。 Critical CSS —— 根据文章Implementing Critical CSS on your website，可以提高首页面的加载速度。 Workbox Service Worker —— 我们可以使用Google的Workbox项目为我们创建一个Service Worker ，了解我们项目的所有东西[这句翻译的有点问题，可以看原文理解]。PWA，我们来了！ PostCSS —— 我认为它是“css的babel”，像sass和scss都是基于它来构建，它让你可以使用即将推出的css功能。 Image Optimization —— 目前，图片仍然是大部分网页呈现的主要内容，所以可以通过mozjpeg，optipng，svgo等自动化工具来压缩优化图片资源是很有必要的。 Automatic .webp Creation —— Chrome、Edge和FireFox都支持.webp文件，它比jpeg体积更小，节省资源。 VueJS —— VueJs是我这次用的前端框架，我希望能够通过单个文件.vue组件作为开发过程的一部分。 Tailwind CSS —— Tailwind是一个实用程序优先的css，我用它在本地开发中快速进行原型设计，然后通过PurgeCss进行生产，从而减小体积。 哇，看起来相当丰富的清单！ 还有很多东西，比如JavaScript自动化、css压缩以及其他标准配置，去构建我们期望的前端系统。我还希望它可以给开发团队使用，开发团队可以使用不同的工具应用在他们的本地开发环境，并使配置易于维护以及可以被其他项目重用。1The importance of maintainability and reusability can’t be understated [可维护性和复用性是非常重要的。] 你使用的前端框架或者技术栈可以跟我的不一样，但应用的规则其实是相同的，所以请继续阅读其余部分，不管你用的是什么技术栈！ PROJECT TREE &amp; ORGANIZATION 为了让你了解程序的整体架构，这里展示一个简单的项目树：12345678910111213141516171819202122232425262728├── example.env├── package.json├── postcss.config.js├── src│ ├── css│ │ ├── app.pcss│ │ ├── components│ │ │ ├── global.pcss│ │ │ ├── typography.pcss│ │ │ └── webfonts.pcss│ │ ├── pages│ │ │ └── homepage.pcss│ │ └── vendor.pcss│ ├── fonts│ ├── img│ │ └── favicon-src.png│ ├── js│ │ ├── app.js│ │ └── workbox-catch-handler.js│ └── vue│ └── Confetti.vue├── tailwind.config.js├── templates├── webpack.common.js├── webpack.dev.js├── webpack.prod.js├── webpack.settings.js└── yarn.lock 完整的代码可以查看: annotated-webpack-4-config在核心配置文件方法，包括： .env—— webpack-dev-server特定于开发环境的设置，不需要在git中检查 webpack.settings.js —— 一个JSON-ish设置文件，我们需要在项目之间编辑的唯一文件 webpack.common.js —— 相同类型的构建放在统一设置文件 webpack.dev.js —— 设置本地开发各个构建 webpack.prod.js —— 设置生产环境各个构建 这是一个如何将以上配置组合成的图表： 目标是你只需要编辑项目之间的金色圆角区域（.env&amp;webpack.settings.js）。 以这种形式分离出来使得配置文件使用变得更加容易，即使你最终修改了我原先提供的各种webpack配置文件，但保持这种方式有助于你长期去对配置文件进行维护。 别着急，我们等下会详细介绍每个文件。 ANNOTATED PACKAGE.JSON 让我们从修改我们的package.json开始入手：12345678910111213141516171819202122232425&#123;&quot;name&quot;: &quot;example-project&quot;,&quot;version&quot;: &quot;1.0.0&quot;,&quot;description&quot;: &quot;Example Project brand website&quot;,&quot;keywords&quot;: [ &quot;Example&quot;, &quot;Keywords&quot;],&quot;homepage&quot;: &quot;https://github.com/example-developer/example-project&quot;,&quot;bugs&quot;: &#123; &quot;email&quot;: &quot;someone@example-developer.com&quot;, &quot;url&quot;: &quot;https://github.com/example-developer/example-project/issues&quot;&#125;,&quot;license&quot;: &quot;SEE LICENSE IN LICENSE.md&quot;,&quot;author&quot;: &#123; &quot;name&quot;: &quot;Example Developer&quot;, &quot;email&quot;: &quot;someone@example-developer.com&quot;, &quot;url&quot;: &quot;https://example-developer.com&quot;&#125;,&quot;browser&quot;: &quot;/web/index.php&quot;,&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/example-developer/example-project.git&quot;&#125;,&quot;private&quot;: true, 这里没什么有趣的东西，只是包含了我们网站的元信息，就像package.json规范中所述。1234&quot;scripts&quot;: &#123;&quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,&quot;build&quot;: &quot;webpack --config webpack.prod.js --progress --hide-modules&quot;&#125;, 上述脚本代表了我们为项目提供的两个主要构建步骤： dev —— 只要我们修改了项目的代码，启动该配置后，它会使用webpack-dev-server来实现热模块替换（HMR），内存编译以及其他细节处理。 build —— 当我们进行生产部署时，它会执行所有花哨以及耗时的事情，例如Critical CSS、JavaScript压缩等 我们只需要在命令行执行以下操作：如果我们使用的是yarn，输入yarn dev或者yarn build；如果使用的是npm，输入npm run dev或者npm run build。这些是你唯一需要使用的两个命令。 请注意，不仅可以通过–config配置，我们还可以传入单独的配置文件进行配置。这样我们可以将webpack配置分解为单独的逻辑文件，因为与生产环境构建相比，我们将为开发环境的构建做很多不同的事情。接下来我们的browserslist配置： 123456789101112131415161718192021222324&quot;browserslist&quot;: &#123; &quot;production&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;Firefox ESR&quot; ], &quot;legacyBrowsers&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;Firefox ESR&quot; ], &quot;modernBrowsers&quot;: [ &quot;last 2 Chrome versions&quot;, &quot;not Chrome &lt; 60&quot;, &quot;last 2 Safari versions&quot;, &quot;not Safari &lt; 10.1&quot;, &quot;last 2 iOS versions&quot;, &quot;not iOS &lt; 10.3&quot;, &quot;last 2 Firefox versions&quot;, &quot;not Firefox &lt; 54&quot;, &quot;last 2 Edge versions&quot;, &quot;not Edge &lt; 15&quot; ]&#125;, 这是一个基于人类可读配置的特定浏览器列表，PostCSS autoprefixer默认使用在production设置中，我们将legacyBrowsers和modernBrowsers传递给Babel用来处理传统[过去]和现代js包的构建[处理转码问题，兼容es6等写法]，后面会有详细介绍。 接着是devDependencies，它是构建系统所需的所有npm包：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.1.0&quot;, &quot;@babel/plugin-syntax-dynamic-import&quot;: &quot;^7.0.0&quot;, &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.1.0&quot;, &quot;@babel/preset-env&quot;: &quot;^7.1.0&quot;, &quot;@babel/register&quot;: &quot;^7.0.0&quot;, &quot;@babel/runtime&quot;: &quot;^7.0.0&quot;, &quot;autoprefixer&quot;: &quot;^9.1.5&quot;, &quot;babel-loader&quot;: &quot;^8.0.2&quot;, &quot;clean-webpack-plugin&quot;: &quot;^0.1.19&quot;, &quot;copy-webpack-plugin&quot;: &quot;^4.5.2&quot;, &quot;create-symlink-webpack-plugin&quot;: &quot;^1.0.0&quot;, &quot;critical&quot;: &quot;^1.3.4&quot;, &quot;critical-css-webpack-plugin&quot;: &quot;^0.2.0&quot;, &quot;css-loader&quot;: &quot;^1.0.0&quot;, &quot;cssnano&quot;: &quot;^4.1.0&quot;, &quot;dotenv&quot;: &quot;^6.1.0&quot;, &quot;file-loader&quot;: &quot;^2.0.0&quot;, &quot;git-rev-sync&quot;: &quot;^1.12.0&quot;, &quot;glob-all&quot;: &quot;^3.1.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;ignore-loader&quot;: &quot;^0.1.2&quot;, &quot;imagemin&quot;: &quot;^6.0.0&quot;, &quot;imagemin-gifsicle&quot;: &quot;^5.2.0&quot;, &quot;imagemin-mozjpeg&quot;: &quot;^7.0.0&quot;, &quot;imagemin-optipng&quot;: &quot;^5.2.1&quot;, &quot;imagemin-svgo&quot;: &quot;^7.0.0&quot;, &quot;imagemin-webp&quot;: &quot;^4.1.0&quot;, &quot;imagemin-webp-webpack-plugin&quot;: &quot;^1.0.2&quot;, &quot;img-loader&quot;: &quot;^3.0.1&quot;, &quot;mini-css-extract-plugin&quot;: &quot;^0.4.3&quot;, &quot;moment&quot;: &quot;^2.22.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^5.0.1&quot;, &quot;postcss&quot;: &quot;^7.0.2&quot;, &quot;postcss-extend&quot;: &quot;^1.0.5&quot;, &quot;postcss-hexrgba&quot;: &quot;^1.0.1&quot;, &quot;postcss-import&quot;: &quot;^12.0.0&quot;, &quot;postcss-loader&quot;: &quot;^3.0.0&quot;, &quot;postcss-nested&quot;: &quot;^4.1.0&quot;, &quot;postcss-nested-ancestors&quot;: &quot;^2.0.0&quot;, &quot;postcss-simple-vars&quot;: &quot;^5.0.1&quot;, &quot;purgecss-webpack-plugin&quot;: &quot;^1.3.0&quot;, &quot;purgecss-whitelister&quot;: &quot;^2.2.0&quot;, &quot;resolve-url-loader&quot;: &quot;^3.0.0&quot;, &quot;sane&quot;: &quot;^4.0.1&quot;, &quot;save-remote-file-webpack-plugin&quot;: &quot;^1.0.0&quot;, &quot;style-loader&quot;: &quot;^0.23.0&quot;, &quot;symlink-webpack-plugin&quot;: &quot;^0.0.4&quot;, &quot;terser-webpack-plugin&quot;: &quot;^1.1.0&quot;, &quot;vue-loader&quot;: &quot;^15.4.2&quot;, &quot;vue-style-loader&quot;: &quot;^4.1.2&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.17&quot;, &quot;webapp-webpack-plugin&quot;: &quot;https://github.com/brunocodutra/webapp-webpack-plugin.git&quot;, &quot;webpack&quot;: &quot;^4.19.1&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^3.0.2&quot;, &quot;webpack-cli&quot;: &quot;^3.1.1&quot;, &quot;webpack-dashboard&quot;: &quot;^2.0.0&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.9&quot;, &quot;webpack-manifest-plugin&quot;: &quot;^2.0.4&quot;, &quot;webpack-merge&quot;: &quot;^4.1.4&quot;, &quot;webpack-notifier&quot;: &quot;^1.6.0&quot;, &quot;workbox-webpack-plugin&quot;: &quot;^3.6.2&quot;&#125;, 没错，这里面依赖了很多npm包，但我们的构建过程确实做的事情需要用到它们。 最后，dependencies的使用：1234567&quot;dependencies&quot;: &#123; &quot;@babel/polyfill&quot;: &quot;^7.0.0&quot;, &quot;axios&quot;: &quot;^0.18.0&quot;, &quot;tailwindcss&quot;: &quot;^0.6.6&quot;, &quot;vue&quot;: &quot;^2.5.17&quot;, &quot;vue-confetti&quot;: &quot;^0.4.2&quot;&#125; 显然，对于一个真实存在的网站或者应用，dependencies中会有更多npm包，但我们现在专注于构建过程。 ANNOTATED WEBPACK.SETTINGS.JS 我还使用了我在 A Bet­ter package.json for the Fron­tend arti­cle一文中讨论过的类似方法，为了封锁从项目之间配置变为单独的webpack.settings.js，并保持webpack配置本身不变。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Macbook利用双网卡同时连内外网]]></title>
    <url>%2F2018%2F12%2F10%2FmacRouteConfig%2F</url>
    <content type="text"><![CDATA[很多单位为了安全，需要使用网线连接内网，此时不能连接外网，无线可以连接外网，却又不能完成部分在内网才能完成的操作。windows下使用双网卡的配置还比较常见，同样移植到mac下，却有许多小问题，本文将详细讲述一下macOS底下应该怎样配置路由表，实现双网卡同时连接内外网。 首先，先查看一下路由表，了解一下基本情况打开终端，输入1netstat -rt 查看路由表的配置情况，我的如下 解释一下这其中的参数123456789101112131. 第一列：Destination，目标地，意思是：后面的参数代表着，如果前往这个ip的话，应该如何分配网关，网卡等，以及状态信息，都是针对前往这个ip的情况的1. 第二列：Gateway，网关，意思是：如果需要前往这个ip，应该从哪个网关过去，这里有两种情况，即有内外网用不同网关的，也有内外网用相同网关的。2/1. 第三列：Flags，标志位，和本文的重点无关，暂略1. 第四列：Refs，可以简单的理解为重要性，相同的ip，相同的网关，用这个重要性来区分使用哪个网卡1. 第五列：Use，使用情况1. 第六列：Netif，网卡号，net interface，如图，我有两张网卡，这里的en0，en10分别代表了我的两张网卡，不同的机器名称可能不同，但是意思是一样的，至于那张是无线网卡，需要自己去区分1. 第七列：Expire，和本文的重点无关，暂略 然后明确一下我们应该如何修改看一下我的原始的表 原始表插上网线之后，我的表是这样的，当前的状况是连的上内网，连不上外网。 根据表上看到，default目标两张网卡可以走，但是refs下看到en10的优先级比较高，根据我的状况，外网地址都无法访问，外网地址属于default部分，所以得出判断en10是有线网卡，因为它的优先级较高导致去外网的ip都由有线网卡进行转发，所以上不了网了，那么自然，en0就是无线网卡。 开始修改第一步：修改无线网卡的优先级，使之大于有线网卡修改无线网卡的优先级进入系统偏好设置，网络，左下角的齿轮，更改服务顺序，拖动wifi到有线网卡上面就可以了（我的有线网卡是AX88772A） 此时变成的状态是连着无线，插着网卡，以无线网卡优先，即上不了内网，可以上外网（苹果默认的是插上有线网络有线优先） 第二步：修改连接内网使用的网卡这里有两种情况 一、公司里内外网分两个路由：此时只需要修改前往公司内网地址的网关就可以了，比如你需要访问的内网地址是10.10.15.*，而公司的内网网关是10.10.15.255，那么就这样写1sudo route add -net 10.10.15.0 -netmask 255.255.255.0 10.10.15.255&apos; 其中，0表示的是默认default，netmask是子网掩码，不是重点就不提了。 二、公司里内外网是一个路由：此时需要有线网卡转发内网链接，无线网卡转发外网链接，写法如下1sudo route add -net 10.10.15.0 -netmask 255.255.255.0 -interface en10 如果存在的话先sudo route delete一下。 至此，应该是修改完成了，可以试一试，应该是确实是内外网都可以正常访问了 第三步：如何自动在每次启动的时候都切换到当前的路由表当mac每次重启的时候，路由表都会被重置，这在windows里也是一样，但是windows里可以永久的修改路由表，而我们不希望这么做，那么就用到了macOS里好用的小机器人 Automator Automator它在mac自带的工具里，我们打开它，选择应用程序，在第二列中选择运行AppleScript，随后我们就要在Automator中编写一段mac的自动化脚本。 写入脚本把我们刚刚编辑的内容都用系统管理员权限写入脚本，并保存成一个应用程序就可以了，以后每次开机，都只需要双击就可以重新恢复路由配置。如果还需要更简便一点的话，只需要在系统偏好，用户与群组中，登录项里加入这个Automator的小程序就可以了 在登录项中加入Automator小程序完成，这样每次启动的时候都会恢复至当前的路由配置了 总结拥有的资源就要良好的利用起来，两块网卡，为什么不能同时连接内外网？搞懂了原理，才能方便生活！]]></content>
      <categories>
        <category>Mac使用</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】80%的人不知道的Sketch小技巧]]></title>
    <url>%2F2018%2F09%2F22%2FsketchTips%2F</url>
    <content type="text"><![CDATA[钢笔工具绘制矢量图形时，你可以按住 shift 键再画之后的点，Sketch会自动帮你对齐到前一点的45度角方向，这在你绘制直线时会非常方便。如果你是在两点之间添加新的锚点时按住 shift 键，你便会得到两点间的锚点。如果你按住 command 键，单击两点间的线条，Sketch则会帮你在线条的正中间添加锚点。 矢量图工具绘制如果你想改变图形的起始点，你需要按住空格键，这样你将会修改起始点，而不是图形的大小 大小我们有一个很特别的输入框，鼠标悬停上去时你会看见上下两个小剪头出现在文本区域右边，你可以单击他们来增减图形的大小。如果你按住 shift 则会以 10 为单位变化。如果你按住 option 键，则会以0.1 为单位变化。一旦你开始直接编辑输入框，上下剪头就会消失，但这个功能依然可用，你可以用键盘上的上下方向键配合 shift 或 option 键来完成。 渐变你可以按下1-9的数字键来在渐变线的 10%-90% 的位置添加新的节点，所以如果按下 5，就能将节点添加在正中间。如果你想在两个节点的正中间添加，则按下 = 键即可。还可以使用 tab 键快速的在不同节点中切换，用方向键（也可以同时按住 shift 键）移动节点。 背景模糊背景模糊是在苹果发布 iOS 7之后添加的功能，需要确认有一个半透明的图层在表面应用了背景模糊，这样下层的内容才会出现模糊效果。需要注意的是，模糊是一种非常消耗资源的渲染效果，图层越大，模糊就需要占用更多的内存空间和处理器能力。尽量少使用模糊，如果你一定要在背景模糊和普通模糊中选择，那么选择普通模糊吧。 分离路径所有的复制图形都会被视为原图形的子路径，如果你想让他们成为完全独立的图层，你只需从菜单栏进入 编辑 &gt; 路径 &gt; 分离 (Layer &gt; Paths &gt; Split)即可。 文字转曲不要将很长一段文字都转化为矢量图形，这会大大减缓文件的运行速度。将一小段文字转化为大量包含布尔运算的子路径是非常非常消耗系统内存的，如果你不得不转换一段文字，那么你可以先将一段文字尽可能分成多个短文本，然后再一个个的转化为矢量。不过既然你现在可以直接在文本上运用渐变等效果，大多数时候你都不会需要将文本转化为轮廓。 路径文字当你进入顶端的编辑菜单 &gt; 文本路径 (Edit &gt; Text on Path)，Sketch会帮你把文本图层贴合的放在它下一层的矢量图形上面。值得注意的是，两者的顺序必须是矢量图形在文本图层的下面，才能得到这样的效果。 抗锯齿顺利实现子像素抗锯齿效果，文本必需出现在一个不透明的（有色的）背景上，因为系统需要知道最终的颜色对比结果是什么样的。这一点与图层混合模式是相冲突的。要实现图层混合模式，Sketch 需要在一个透明背景上渲染所有的图层，这样这些图层才能像你所期望的那样混合在一起，最终结果再渲染回 Sketch 的白色画布上。如果没有一个不透明背景我们就不能渲染抗锯齿的文字，但是有了不透明的背景我们又不能渲染图层的混合模式了。这就意味着，一旦你的画布中出现了一个有混合模式的图层，Sketch 就不得不运用透明背景的算法，而无法给文字实现子像素抗锯齿效果了。 图片色彩校正如果你想微调一张现有图片的颜色，那可以使用检查器中的色彩校正面板来实现，在这，你可以改变图片的饱和度，亮度和对比色。需要注意的是，这一个不破坏原图的操作，所以你稍后还可以再次更改这些参数。 九宫格正常情况下，你缩放一个位图时，他们会对称的向各个方向变化。但有时这并不是你想要的，比如说你在做一个网页设计，你也许会想要一个 safari 里的白色背景，随着网页内容变多而变长。我们特意增加了针对图片的九宫格缩放来解决这个问题。进入图层 &gt; 转化为九宫格图片 （Layer &gt; Convert to Nine-slice Image），你会发现图片被划分为了9个区域。你可以单击拖拽四个中心点的任一个来调整9个区域。 蒙板普通蒙板Sketch里的蒙版可以让你有选择性的显示出图层的一部分。比如说在一个图片上圆形蒙版，那么这张图片就只会显示出圆形内部的内容。所有的图形都可以变成蒙版，你只需要先选中图形，然后进入图层 &gt; 使用图形蒙版(Layer &gt; Use as Mask), 所有在这个蒙版上面的图形都会被剪切成蒙版的内容显示出来。 限制蒙版如果你不想接下来所有的图层都被蒙版剪切，那么你可以将蒙版和想要被剪切的图层单独编组，一次来限制蒙版的使用情景。一旦蒙版被编组，其他一切在组外的图层就都不会被蒙版剪切了。在无法编组的情况下，你还可以通过以下方式限制蒙版：・选中一个你想从剪切蒙版中释放出来的图层・进入图层 &gt; 忽略底层蒙版 (Layer &gt; Ignore Underlying Mask)这一层图层和它以上的所有图层就都不会被蒙版剪切了。当你调整图层顺序的时候则需要格外注意，个别图层可能会意外的被蒙版剪切。 ALPHA 蒙版默认情况下，一个蒙版会显示出所在区域的图片，隐藏其他的地方。另一种使用蒙版的方式是通过 ALPHA 蒙版建立渐变区域，来具体选择图片的各部分是否可见使用这个方法你可以先选中蒙版，选择 图层 (Layer) &gt; 蒙版模式 (Mask Mode) &gt; ALPHA 蒙版 (ALPHA Mask) 来实现。 图层复制command + D，Sketch则会重复你刚才的操作，复制出一个一样的图层。 编组选择想从深深的编组层级中直接选中某一具体图层，你可以按住 command 键，来直接选择埋在组里的图层，无需不停的双击以进入更深的层级，这将省去你不少的时间。同时按住 shift 键，则能选择多个图层。 叠加选择右击鼠标，从菜单中选择 “选择图层”（Pick Layer），便会显示出鼠标底下的所有图层列表。按住 option 键，Sketch 会选中第二层图层，而不是最上层的。如果某个区域有多个图层重叠，而你想选择第三层，那么还是需要用到上面说的右击鼠标的方法来选择了。 鼠标框选如果你同时按住 option 键，则只会选中完全被包括在所画选取内的图层 改变大小可以直接使用键盘调整图层大小。按住 command 键和方向键来操作。⌘→会将图层宽度增加 1px，⌘←则会将宽度减少 1px。同样的，⌘↓ 和 ⌘↑则分别将长度增加和减少 1px。如果你同时按住 shift 键，每一次更改的数值将会变成 10 px。改变一个图层的大小时，它的式样元素并不会随之变大变小：一个 10x10的图形上 1px的描边在这个图形被拉伸至 50x50的时候，将仍保持 1px的描边。想要更改图层大小的同时一起更改式样，那就使用编辑菜单当中的缩放工具吧。 图层扁平化当你使用扁平化功能（ Flattening），Sketch 会试着将一个图形里的多个子路径呈现为一个路径——也就是将层级结构变得更扁平。但是有些图形是无法扁平为一个路径的，比如说一个环状图形，将只能被呈现为两个路径：一个是外圈路径，一个是内圈路径当 Sketch 不能完成扁平化的命令时，会出现一个小警告，如果你继续坚持，那有的子路径可能被替换，也许比之前少，也许和之前一样多。也许在你之前使用的绘图应用中，你每次添加布尔运算后到要让图层扁平一次，但在 Sketch 当中大可不必这么做，你可以尽情添加无数曾布尔运算，而无需使用扁平命令。 多页面操作你可以用无限精准的分辨率无关模式来查看画布，或者打开像素模式来查看每一个像素导出成JPG或者PNG文件后的样子。值得注意的是，有些效果——比如模糊——会自动将画布的一部分以像素模式显示，因为模糊本身就是一个基于像素的效果。值得注意的是，当模糊半径被设置为0的时候，文本图层的内阴影才是最好看的。扩散并不适用于文本图层。 放大缩小视图可以按住 command 键并滚动鼠标滚轮来放大查看。还能用 Z 键来快速放大某一特定区域，单击画布任一点拖拽出矩形区域即可。 切片如果你在文件名中加入了一个斜杠 (一个”/“)，那么Sketch就会自动新建一个文件夹，并把这个文件放入其中。举个例子，如果你将切片命名为 foo/bar.png ，那么Sketch会先帮你创建一个叫做 foo 的文件夹，然后在里面创建一个叫 bar.png 的图片。]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Sketch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method Swizzling 原理]]></title>
    <url>%2F2017%2F04%2F12%2FmethodSwizzlingIntroduce%2F</url>
    <content type="text"><![CDATA[在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法吗？在Objective-C编程中，如何实现hook呢？标题有点大，计划分几篇来总结。本文主要介绍针对selector的hook，主角被标题剧透了———— Method Swizzling 。 Method Swizzling 原理在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，我们可以利用 class_replaceMethod 来修改类，我们可以利用 method_setImplementation 来直接设置某个方法的IMP，……归根结底，都是偷换了selector的IMP，如下图所示： Method Swizzling 实践举个例子好了，我想钩一下NSArray的lastObject 方法，只需两个步骤。 第一步：给NSArray加一个我自己的lastObject1234567891011#import &quot;NSArray+Swizzle.h&quot; @implementation NSArray (Swizzle) - (id)myLastObject &#123; id ret = [self myLastObject]; NSLog(@&quot;********** myLastObject *********** &quot;); return ret; &#125; @end 乍一看，这不递归了么？别忘记这是我们准备调换IMP的selector，[self myLastObject] 将会执行真的 [self lastObject] 。 第二步：调换IMP123456789101112131415161718#import #import &quot;NSArray+Swizzle.h&quot; int main(int argc, char *argv[]) &#123; @autoreleasepool &#123; Method ori_Method = class_getInstanceMethod([NSArray class], @selector(lastObject)); Method my_Method = class_getInstanceMethod([NSArray class], @selector(myLastObject)); method_exchangeImplementations(ori_Method, my_Method); NSArray *array = @[@&quot;0&quot;,@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;]; NSString *string = [array lastObject]; NSLog(@&quot;TEST RESULT : %@&quot;,string); return 0; &#125; &#125; 控制台输出Log：2013-07-18 16:26:12.585 Hook[1740:c07] ** myLastObject ***2013-07-18 16:26:12.589 Hook[1740:c07] TEST RESULT : 3 结果很让人欣喜，是不是忍不住想给UIWebView的loadRequest: 加 TODO 了呢？ Method Swizzling 的封装之前在github上找到的RNSwizzle，推荐给大家，可以搜一下。1234567891011121314151617181920212223// // RNSwizzle.m // MethodSwizzle #import &quot;RNSwizzle.h&quot; #import @implementation NSObject (RNSwizzle) + (IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP &#123; Class class = [self class]; Method origMethod = class_getInstanceMethod(class, origSelector); IMP origIMP = method_getImplementation(origMethod); if(!class_addMethod(self, origSelector, newIMP, method_getTypeEncoding(origMethod))) &#123; method_setImplementation(origMethod, newIMP); &#125; return origIMP; &#125; @end Method Swizzling 危险不危险针对这个问题，我在stackoverflow上看到了满意的答案，这里翻译一下，总结记录在本文中，以示分享： 使用 Method Swizzling 编程就好比切菜时使用锋利的刀，一些人因为担心切到自己所以害怕锋利的刀具，可是事实上，使用钝刀往往更容易出事，而利刀更为安全。Method swizzling 可以帮助我们写出更好的，更高效的，易维护的代码。但是如果滥用它，也将会导致难以排查的bug。 背景好比设计模式，如果我们摸清了一个模式的门道，使用该模式与否我们自己心里有数。单例模式就是一个很好的例子，它饱受争议但是许多人依旧使用它。Method Swizzling也是一样，一旦你真正理解它的优势和弊端，使用它与否你应该就有你自己的观点。 讨论这里是一些 Method Swizzling的陷阱：Method swizzling is not atomicChanges behavior of un-owned codePossible naming conflictsSwizzling changes the method’s argumentsThe order of swizzles mattersDifficult to understand (looks recursive)Difficult to debug 我将逐一分析这些点，增进对Method Swizzling的理解的同时，并搞懂如何应对。 1Method swizzling is not atomic 我所见过的使用method swizzling实现的方法在并发使用时基本都是安全的。95%的情况里这都不会是个问题。通常你替换一个方法的实现，是希望它在整个程序的生命周期里有效的。也就是说，你会把 method swizzling 修改方法实现的操作放在一个加号方法 +(void)load里，并在应用程序的一开始就调用执行。你将不会碰到并发问题。假如你在 +(void)initialize初始化方法中进行swizzle，那么……rumtime可能死于一个诡异的状态。 1Changes behavior of un-owned code 这是swizzling的一个问题。我们的目标是改变某些代码。swizzling方法是一件灰常灰常重要的事，当你不只是对一个NSButton类的实例进行了修改，而是程序中所有的NSButton实例。因此在swizzling时应该多加小心，但也不用总是去刻意避免。 想象一下，如果你重写了一个类的方法，而且没有调用父类的这个方法，这可能会引起问题。大多数情况下，父类方法期望会被调用（至少文档是这样说的）。如果你在swizzling实现中也这样做了，这会避免大部分问题。还是调用原始实现吧，如若不然，你会费很大力气去考虑代码的安全问题。 1Possible naming conflicts 命名冲突贯穿整个Cocoa的问题. 我们常常在类名和类别方法名前加上前缀。不幸的是，命名冲突仍是个折磨。但是swizzling其实也不必过多考虑这个问题。我们只需要在原始方法命名前做小小的改动来命名就好，比如通常我们这样命名：1234567891011121314151617181920@interface NSView : NSObject - (void)setFrame:(NSRect)frame; @end @implementation NSView (MyViewAdditions) - (void)my_setFrame:(NSRect)frame &#123; // do custom work [self my_setFrame:frame]; &#125; + (void)load &#123; [self swizzle:@selector(setFrame:) with:@selector(my_setFrame:)]; &#125; @end 这段代码运行正确，但是如果my_setFrame: 在别处被定义了会发生什么呢？这个问题不仅仅存在于swizzling，这里有一个替代的变通方法：12345678910111213141516171819@implementation NSView (MyViewAdditions) static void MySetFrame(id self, SEL _cmd, NSRect frame); static void (*SetFrameIMP)(id self, SEL _cmd, NSRect frame); static void MySetFrame(id self, SEL _cmd, NSRect frame) &#123; // do custom work SetFrameIMP(self, _cmd, frame); &#125; + (void)load &#123; [self swizzle:@selector(setFrame:) with:(IMP)MySetFrame store:(IMP *)&amp;SetFrameIMP]; &#125; @end 看起来不那么Objectice-C了（用了函数指针），这样避免了selector的命名冲突。 最后给出一个较完美的swizzle方法的定义：1234567891011121314151617181920212223typedef IMP *IMPPointer; BOOL class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMPPointer store) &#123; IMP imp = NULL; Method method = class_getInstanceMethod(class, original); if (method) &#123; const char *type = method_getTypeEncoding(method); imp = class_replaceMethod(class, original, replacement, type); if (!imp) &#123; imp = method_getImplementation(method); &#125; &#125; if (imp &amp;&amp; store) &#123; *store = imp; &#125; return (imp != NULL); &#125; @implementation NSObject (FRRuntimeAdditions) + (BOOL)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store &#123; return class_swizzleMethodAndStore(self, original, replacement, store); &#125; @end 1Swizzling changes the method&apos;s arguments 我认为这是最大的问题。想正常调用method swizzling 将会是个问题。1[self my_setFrame:frame]; 直接调用my_setFrame: ， runtime做的是1objc_msgSend(self, @selector(my_setFrame:), frame); runtime去寻找my_setFrame:的方法实现, _cmd参数为 my_setFrame: ，但是事实上runtime找到的方法实现是原始的 setFrame: 的。 一个简单的解决办法：使用上面介绍的swizzling定义。 1The order of swizzles matters 多个swizzle方法的执行顺序也需要注意。假设 setFrame: 只定义在NSView中，想像一下按照下面的顺序执行：12345678910111213141516[NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)]; [NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)]; [NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)]; What happens when the method on NSButton is swizzled? Well most swizzling will ensure that it&apos;s not replacing the implementation of setFrame: for all views, so it will pull up the instance method. This will use the existing implementation to re-define setFrame: in the NSButton class so that exchanging implementations doesn&apos;t affect all views. The existing implementation is the one defined on NSView. The same thing will happen when swizzling on NSControl (again using the NSView implementation).When you call setFrame: on a button, it will therefore call your swizzled method, and then jump straight to the setFrame: method originally defined on NSView. The NSControl and NSView swizzled implementations will not be called.But what if the order were:[NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)]; [NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)]; [NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)]; Since the view swizzling takes place first, the control swizzling will be able to pull up the right method. Likewise, since the control swizzling was before the button swizzling, the button will pull up the control&apos;s swizzled implementation of setFrame:. This is a bit confusing, but this is the correct order. How can we ensure this order of things?Again, just use load to swizzle things. If you swizzle in load and you only make changes to the class being loaded, you&apos;ll be safe. The load method guarantees that the super class load method will be called before any subclasses. We&apos;ll get the exact right order! 这段贴了原文，硬翻译太拗口……总结一下就是：多个有继承关系的类的对象swizzle时，从子类对象开始 。 如果先swizzle父类对象，那么后面子类对象swizzle时就无法拿到真正的原始方法实现了。 多个有继承关系的类的对象swizzle时，先从父对象开始。 这样才能保证子类方法拿到父类中的被swizzle的实现。在+(void)load中swizzle不会出错，就是因为load类方法会默认从父类开始调用。 1Difficult to understand (looks recursive) （新方法的实现）看起来像递归，但是看看上面已经给出的 swizzling 封装方法, 使用起来就很易读懂.这个问题是已完全解决的了！ 1Difficult to debug debug时打出的backtrace，其中掺杂着被swizzle的方法名，一团糟啊！上面介绍的swizzle方案，使backtrace中打印出的方法名还是很清晰的。但仍然很难去debug，因为很难记住swizzling影响过什么。给你的代码写好文档（即使只有你一个人会看到）。养成一个好习惯，不会比调试多线程问题还难的。 结论如果使用恰当，Method swizzling 还是很安全的.一个简单安全的方法是，仅在load中swizzle。 和许多其他东西一样，它也是有危险性的，但理解它了也就可以正确恰当的使用它了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
