<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React 使用Upload插件上传读取文件内容]]></title>
    <url>%2F2018%2F12%2F10%2FreactUpload%2F</url>
    <content type="text"><![CDATA[问题背景某一天，公司里需要一个功能，一个可以把一份参数多如牛毛的配置文件本地存储下来，本地也可以把文件读取出来这样便利的功能。分析一下这个需求，主要就是要以json的格式，保存，和web页面读取json文件的这样两个功能。公司的工程是react编写的，可能对vue和原生js都有一定了解的你，对react并不熟悉，那么，如何解决这个问题 分步解决一、保存JSON格式的文件首先，我们假定拿到了一个json格式的变量1var jsonData; 那么，再写一个download的工具类1234567891011121314151617/* * 下载文件* */function download(content, filename) &#123;// 创建隐藏的可下载链接var eleLink = document.createElement(&apos;a&apos;);eleLink.download = filename;eleLink.style.display = &apos;none&apos;;// 字符内容转变成blob地址var blob = new Blob([content]);eleLink.href = URL.createObjectURL(blob);// 触发点击document.body.appendChild(eleLink);eleLink.click();// 然后移除document.body.removeChild(eleLink);&#125; 发现问题！直接download下来的是没有格式化过的文本，乱成一团，毫无可读性可言。一个formatjson非常重要！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 格式化json文件，便于json文件的下载* */function formatJson(json, options) &#123; var reg = null, formatted = &apos;&apos;, pad = 0, PADDING = &apos; &apos;; options = options || &#123;&#125;; options.newlineAfterColonIfBeforeBraceOrBracket = (options.newlineAfterColonIfBeforeBraceOrBracket === true) ? true : false; options.spaceAfterColon = (options.spaceAfterColon === false) ? false : true; if (typeof json !== &apos;string&apos;) &#123; json = JSON.stringify(json); &#125; else &#123; json = JSON.parse(json); json = JSON.stringify(json); &#125; reg = /([\&#123;\&#125;])/g; json = json.replace(reg, &apos;\r\n$1\r\n&apos;); reg = /([\[\]])/g; json = json.replace(reg, &apos;\r\n$1\r\n&apos;); reg = /(\,)/g; json = json.replace(reg, &apos;$1\r\n&apos;); reg = /(\r\n\r\n)/g; json = json.replace(reg, &apos;\r\n&apos;); reg = /\r\n\,/g; json = json.replace(reg, &apos;,&apos;); if (!options.newlineAfterColonIfBeforeBraceOrBracket) &#123; reg = /\:\r\n\&#123;/g; json = json.replace(reg, &apos;:&#123;&apos;); reg = /\:\r\n\[/g; json = json.replace(reg, &apos;:[&apos;); &#125; if (options.spaceAfterColon) &#123; reg = /\:/g; json = json.replace(reg, &apos;:&apos;); &#125; (json.split(&apos;\r\n&apos;)).forEach(function (node, index) &#123; var i = 0, indent = 0, padding = &apos;&apos;; if (node.match(/\&#123;$/) || node.match(/\[$/)) &#123; indent = 1; &#125; else if (node.match(/\&#125;/) || node.match(/\]/)) &#123; if (pad !== 0) &#123; pad -= 1; &#125; &#125; else &#123; indent = 0; &#125; for (i = 0; i &lt; pad; i++) &#123; padding += PADDING; &#125; formatted += padding + node + &apos;\r\n&apos;; pad += indent; &#125;); return formatted; &#125; 一行调用！1download(formatJson(jsonData), &quot;configuration.json&quot;); 二、读取JSON格式的文件react有很多轮子，upload当然也有相应封装好的工具，引入！（在这之前别忘了npm install react-fileupload -save）1import FileUpload from &apos;react-fileupload&apos; 写一份配置文件，这个文件中写出的API这边有https://www.jianshu.com/p/3aa9d5ad41b012345678910111213this.options = &#123; baseUrl: &apos;https://jsonplaceholder.typicode.com/posts/&apos;, param: &#123; _c: &apos;file&apos;, _a: &apos;UploadFile&apos; &#125;, chooseFile: this.chooseFile, doUpload: this.do_upload, uploading: (progress) =&gt; &#123; this.uploading(progress); &#125;, uploadSuccess: this.upload_success, uploadError: this.upload_error, uploadFail: this.upload_fail,&#125; 操作在那边已经很清晰啦，我就不多说了1234&lt;FileUpload options=&#123;this.options&#125;&gt; &lt;button ref="chooseBtn"&gt;Chose file&lt;/button&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button ref="uploadBtn"&gt;upload&lt;/button&gt;&lt;/FileUpload&gt; 拿到文件之后，当然要把文件内容在web上就解析出来1234567var self = this;var reader = new FileReader();reader.readAsText(files[0]);reader.onload = function () &#123; console.log($.parseJSON(reader.result)); var fileContent = $.parseJSON(reader.result)&#125; 好啦，fileContent就是里面的内容，json对象，拿到之后，就可以为所欲为了！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用于前端开发的webpack4配置]]></title>
    <url>%2F2018%2F12%2F10%2FwebpackConfig%2F</url>
    <content type="text"><![CDATA[随着web开发变得越来越复杂，我们需要使用工具来帮助我们构建现代化网站。这是一个完整通过复杂webpack4配置的线上生产例子。构建现代化网站已经成为自定义应用程序开发，网站期望能做的更多，具有传统应用的功能，而不仅仅是一个推广网站。 随着一个流程变得复杂时，我们就会将它分解为可管理的组件，并使用工具进行自动化构建，比如制造汽车、起草法案[法律文件]、建立网站。1使用正确的工具完成工作 像webpack这样的工具一直处于现代web开发的最前沿，正是因为如此，它帮助我们构建复杂的事物。 webpack4拥有一些意想不到的改进，最吸引我的就是它在构建速度上面变得有多快，所以我决定采用它。hold住，因为这是一篇充满大量信息的长篇文章。 采用webpack一年多以前，我发表了一篇文章： A Gulp Workflow for Frontend Development Automation [用于前端自动化的gulp工作流]，讲解了如何使用gulp完成同样的事情。然而在这段时间里，我越来越多地使用像Vue-JS 和GraphQL 这样的前端框架，如Using VueJS + GraphQL to make Practical Magic 这篇文章。我发现webpack让我更容易的去构建各种类型的网站以及应用程序，而且它也允许我使用最现代化的工具链。还有其他选择： Laravel Mix是基于webpack的构建工具层，它十分简洁，你可以快速启动并运行，它可以在90%的时间内完成你想要的任务，但剩下的10%无论如何都会进入到webpack，目前还不支持webpack4。 如果你只是用VueJS前端框架，那么使用vue-cli是个不错的选择，它也是基于webpack，大部分时间都可以工作，并且为你做一些意想不到的事情。但同样的，当它提供的功能已经满足不了你的需求，你还是需要用到webpack，而且我并不是只使用VueJS。 Neutrino也是基于webpack，我们可以关注博客：Neutrino: How I Learned to Stop Worrying and Love Webpack。神奇的点就是它可以通过像搭乐高积木一样去配置webpack，但学习使用让的成本跟学习webpack其实差不了多少。 如果你选择上述工具（或者其他工具），我不会对你提出任何意见：它们都是基于webpack封装。1理解开发系统中层是如何工作的是有好处的。 最终，你只需要决定你希望站在前端技术金字塔中的哪个位置。某些时候，我认为了解像webpack这样重要的工具是如何工作是有意义的。不久前，我向Sean Larkin（webpack核心团队成员之一）抱怨说webpack就像一个“黑匣子”，他的回答简洁却非常精辟：1It’s only black if you haven’t opened it.[如果你没有打开这个所谓的“黑匣子”，它永远都是未知的。] 他说的对，是时候打开“黑匣子”了。本文不会教你所有关于webpack的知识，甚至是如何安装它，下面有很多、资料给你选择，你可以选择你认为不错的方式： webpack—the Confusing Parts ——简要概述了webpack的工作原理。 webpack documentation —— 建议读webpack官方文档，如果你想学好它的话 webpack fundamentals —— webpack教学视频 How to switch from Gulp to webpack 这样的资料还有很多，相反地本文将用webpack4配置一个复杂的完整工作例子，并添加注释。你可以使用完整的示例，也可以使用它的部分配置项，但希望你可以从中学到一些东西。在我学习webpack的过程中，我发现有很多教程视频，一堆文章给你将如何安装它并添加一些基础配置，但却大部分没有实际线上生产环境的webpack配置示例，所以我写了这篇文章。 WHAT WE GET OUT OF THE BOX 当我开始通过打开“黑匣子”来学习webpack时，我有一份我依赖的技术列表，我想将它成为构建流程的一部分。我也会花时间四处看看，看看在这个过程中，我还能采用什么。 正如在文章 A Pretty Website Isn’t Enough article讨论的那样，网站性能一直都是我关注的重点，所以在配置webpack过程中关注性能问题也很正常。 所以这是我想用webpack为我处理的事情，以及我希望在构建过程中加入的技术： Development / Production —— 在本地开发中，我通过webpack-dev-server进行快速构建，对于生产环境的构建（通常通过buddy.works在Docker容器中构建），我希望尽可能优化每一个点。因此，我们区分dev和prod的配置以及构建。 Hot Module Replacement —— 当我修改了js、css或者页面，我希望网页能够自动刷新，大幅度提高了开发效率：不需要你去点浏览器刷新按钮。 Dynamic Code Splitting —— 我不想手动在配置文件中定义js chunk，所以我让webpack帮我解决这个问题。 Lazy Loading —— 又称异步动态模块加载，在需要时加载所需的代码资源。 Modern &amp; Legacy JS Bundles —— 我想将es2015 + JavaScript模块发布到能够支持全球75%以上的浏览器上，同时为低版本的浏览器提供一个补丁包（包括所有转码和polyfills）。 Cache Busting via manifest.json —— 可以让我们为静态资源设置缓存，同时保证它们在更改使自动重新缓存。 Critical CSS —— 根据文章Implementing Critical CSS on your website，可以提高首页面的加载速度。 Workbox Service Worker —— 我们可以使用Google的Workbox项目为我们创建一个Service Worker ，了解我们项目的所有东西[这句翻译的有点问题，可以看原文理解]。PWA，我们来了！ PostCSS —— 我认为它是“css的babel”，像sass和scss都是基于它来构建，它让你可以使用即将推出的css功能。 Image Optimization —— 目前，图片仍然是大部分网页呈现的主要内容，所以可以通过mozjpeg，optipng，svgo等自动化工具来压缩优化图片资源是很有必要的。 Automatic .webp Creation —— Chrome、Edge和FireFox都支持.webp文件，它比jpeg体积更小，节省资源。 VueJS —— VueJs是我这次用的前端框架，我希望能够通过单个文件.vue组件作为开发过程的一部分。 Tailwind CSS —— Tailwind是一个实用程序优先的css，我用它在本地开发中快速进行原型设计，然后通过PurgeCss进行生产，从而减小体积。 哇，看起来相当丰富的清单！ 还有很多东西，比如JavaScript自动化、css压缩以及其他标准配置，去构建我们期望的前端系统。我还希望它可以给开发团队使用，开发团队可以使用不同的工具应用在他们的本地开发环境，并使配置易于维护以及可以被其他项目重用。1The importance of maintainability and reusability can’t be understated [可维护性和复用性是非常重要的。] 你使用的前端框架或者技术栈可以跟我的不一样，但应用的规则其实是相同的，所以请继续阅读其余部分，不管你用的是什么技术栈！ PROJECT TREE &amp; ORGANIZATION 为了让你了解程序的整体架构，这里展示一个简单的项目树：12345678910111213141516171819202122232425262728├── example.env├── package.json├── postcss.config.js├── src│ ├── css│ │ ├── app.pcss│ │ ├── components│ │ │ ├── global.pcss│ │ │ ├── typography.pcss│ │ │ └── webfonts.pcss│ │ ├── pages│ │ │ └── homepage.pcss│ │ └── vendor.pcss│ ├── fonts│ ├── img│ │ └── favicon-src.png│ ├── js│ │ ├── app.js│ │ └── workbox-catch-handler.js│ └── vue│ └── Confetti.vue├── tailwind.config.js├── templates├── webpack.common.js├── webpack.dev.js├── webpack.prod.js├── webpack.settings.js└── yarn.lock 完整的代码可以查看: annotated-webpack-4-config在核心配置文件方法，包括： .env—— webpack-dev-server特定于开发环境的设置，不需要在git中检查 webpack.settings.js —— 一个JSON-ish设置文件，我们需要在项目之间编辑的唯一文件 webpack.common.js —— 相同类型的构建放在统一设置文件 webpack.dev.js —— 设置本地开发各个构建 webpack.prod.js —— 设置生产环境各个构建 这是一个如何将以上配置组合成的图表： 目标是你只需要编辑项目之间的金色圆角区域（.env&amp;webpack.settings.js）。 以这种形式分离出来使得配置文件使用变得更加容易，即使你最终修改了我原先提供的各种webpack配置文件，但保持这种方式有助于你长期去对配置文件进行维护。 别着急，我们等下会详细介绍每个文件。 ANNOTATED PACKAGE.JSON 让我们从修改我们的package.json开始入手：12345678910111213141516171819202122232425&#123;&quot;name&quot;: &quot;example-project&quot;,&quot;version&quot;: &quot;1.0.0&quot;,&quot;description&quot;: &quot;Example Project brand website&quot;,&quot;keywords&quot;: [ &quot;Example&quot;, &quot;Keywords&quot;],&quot;homepage&quot;: &quot;https://github.com/example-developer/example-project&quot;,&quot;bugs&quot;: &#123; &quot;email&quot;: &quot;someone@example-developer.com&quot;, &quot;url&quot;: &quot;https://github.com/example-developer/example-project/issues&quot;&#125;,&quot;license&quot;: &quot;SEE LICENSE IN LICENSE.md&quot;,&quot;author&quot;: &#123; &quot;name&quot;: &quot;Example Developer&quot;, &quot;email&quot;: &quot;someone@example-developer.com&quot;, &quot;url&quot;: &quot;https://example-developer.com&quot;&#125;,&quot;browser&quot;: &quot;/web/index.php&quot;,&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/example-developer/example-project.git&quot;&#125;,&quot;private&quot;: true, 这里没什么有趣的东西，只是包含了我们网站的元信息，就像package.json规范中所述。1234&quot;scripts&quot;: &#123;&quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,&quot;build&quot;: &quot;webpack --config webpack.prod.js --progress --hide-modules&quot;&#125;, 上述脚本代表了我们为项目提供的两个主要构建步骤： dev —— 只要我们修改了项目的代码，启动该配置后，它会使用webpack-dev-server来实现热模块替换（HMR），内存编译以及其他细节处理。 build —— 当我们进行生产部署时，它会执行所有花哨以及耗时的事情，例如Critical CSS、JavaScript压缩等 我们只需要在命令行执行以下操作：如果我们使用的是yarn，输入yarn dev或者yarn build；如果使用的是npm，输入npm run dev或者npm run build。这些是你唯一需要使用的两个命令。 请注意，不仅可以通过–config配置，我们还可以传入单独的配置文件进行配置。这样我们可以将webpack配置分解为单独的逻辑文件，因为与生产环境构建相比，我们将为开发环境的构建做很多不同的事情。接下来我们的browserslist配置： 123456789101112131415161718192021222324&quot;browserslist&quot;: &#123; &quot;production&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;Firefox ESR&quot; ], &quot;legacyBrowsers&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;Firefox ESR&quot; ], &quot;modernBrowsers&quot;: [ &quot;last 2 Chrome versions&quot;, &quot;not Chrome &lt; 60&quot;, &quot;last 2 Safari versions&quot;, &quot;not Safari &lt; 10.1&quot;, &quot;last 2 iOS versions&quot;, &quot;not iOS &lt; 10.3&quot;, &quot;last 2 Firefox versions&quot;, &quot;not Firefox &lt; 54&quot;, &quot;last 2 Edge versions&quot;, &quot;not Edge &lt; 15&quot; ]&#125;, 这是一个基于人类可读配置的特定浏览器列表，PostCSS autoprefixer默认使用在production设置中，我们将legacyBrowsers和modernBrowsers传递给Babel用来处理传统[过去]和现代js包的构建[处理转码问题，兼容es6等写法]，后面会有详细介绍。 接着是devDependencies，它是构建系统所需的所有npm包：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.1.0&quot;, &quot;@babel/plugin-syntax-dynamic-import&quot;: &quot;^7.0.0&quot;, &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.1.0&quot;, &quot;@babel/preset-env&quot;: &quot;^7.1.0&quot;, &quot;@babel/register&quot;: &quot;^7.0.0&quot;, &quot;@babel/runtime&quot;: &quot;^7.0.0&quot;, &quot;autoprefixer&quot;: &quot;^9.1.5&quot;, &quot;babel-loader&quot;: &quot;^8.0.2&quot;, &quot;clean-webpack-plugin&quot;: &quot;^0.1.19&quot;, &quot;copy-webpack-plugin&quot;: &quot;^4.5.2&quot;, &quot;create-symlink-webpack-plugin&quot;: &quot;^1.0.0&quot;, &quot;critical&quot;: &quot;^1.3.4&quot;, &quot;critical-css-webpack-plugin&quot;: &quot;^0.2.0&quot;, &quot;css-loader&quot;: &quot;^1.0.0&quot;, &quot;cssnano&quot;: &quot;^4.1.0&quot;, &quot;dotenv&quot;: &quot;^6.1.0&quot;, &quot;file-loader&quot;: &quot;^2.0.0&quot;, &quot;git-rev-sync&quot;: &quot;^1.12.0&quot;, &quot;glob-all&quot;: &quot;^3.1.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;ignore-loader&quot;: &quot;^0.1.2&quot;, &quot;imagemin&quot;: &quot;^6.0.0&quot;, &quot;imagemin-gifsicle&quot;: &quot;^5.2.0&quot;, &quot;imagemin-mozjpeg&quot;: &quot;^7.0.0&quot;, &quot;imagemin-optipng&quot;: &quot;^5.2.1&quot;, &quot;imagemin-svgo&quot;: &quot;^7.0.0&quot;, &quot;imagemin-webp&quot;: &quot;^4.1.0&quot;, &quot;imagemin-webp-webpack-plugin&quot;: &quot;^1.0.2&quot;, &quot;img-loader&quot;: &quot;^3.0.1&quot;, &quot;mini-css-extract-plugin&quot;: &quot;^0.4.3&quot;, &quot;moment&quot;: &quot;^2.22.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^5.0.1&quot;, &quot;postcss&quot;: &quot;^7.0.2&quot;, &quot;postcss-extend&quot;: &quot;^1.0.5&quot;, &quot;postcss-hexrgba&quot;: &quot;^1.0.1&quot;, &quot;postcss-import&quot;: &quot;^12.0.0&quot;, &quot;postcss-loader&quot;: &quot;^3.0.0&quot;, &quot;postcss-nested&quot;: &quot;^4.1.0&quot;, &quot;postcss-nested-ancestors&quot;: &quot;^2.0.0&quot;, &quot;postcss-simple-vars&quot;: &quot;^5.0.1&quot;, &quot;purgecss-webpack-plugin&quot;: &quot;^1.3.0&quot;, &quot;purgecss-whitelister&quot;: &quot;^2.2.0&quot;, &quot;resolve-url-loader&quot;: &quot;^3.0.0&quot;, &quot;sane&quot;: &quot;^4.0.1&quot;, &quot;save-remote-file-webpack-plugin&quot;: &quot;^1.0.0&quot;, &quot;style-loader&quot;: &quot;^0.23.0&quot;, &quot;symlink-webpack-plugin&quot;: &quot;^0.0.4&quot;, &quot;terser-webpack-plugin&quot;: &quot;^1.1.0&quot;, &quot;vue-loader&quot;: &quot;^15.4.2&quot;, &quot;vue-style-loader&quot;: &quot;^4.1.2&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.17&quot;, &quot;webapp-webpack-plugin&quot;: &quot;https://github.com/brunocodutra/webapp-webpack-plugin.git&quot;, &quot;webpack&quot;: &quot;^4.19.1&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^3.0.2&quot;, &quot;webpack-cli&quot;: &quot;^3.1.1&quot;, &quot;webpack-dashboard&quot;: &quot;^2.0.0&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.9&quot;, &quot;webpack-manifest-plugin&quot;: &quot;^2.0.4&quot;, &quot;webpack-merge&quot;: &quot;^4.1.4&quot;, &quot;webpack-notifier&quot;: &quot;^1.6.0&quot;, &quot;workbox-webpack-plugin&quot;: &quot;^3.6.2&quot;&#125;, 没错，这里面依赖了很多npm包，但我们的构建过程确实做的事情需要用到它们。 最后，dependencies的使用：1234567&quot;dependencies&quot;: &#123; &quot;@babel/polyfill&quot;: &quot;^7.0.0&quot;, &quot;axios&quot;: &quot;^0.18.0&quot;, &quot;tailwindcss&quot;: &quot;^0.6.6&quot;, &quot;vue&quot;: &quot;^2.5.17&quot;, &quot;vue-confetti&quot;: &quot;^0.4.2&quot;&#125; 显然，对于一个真实存在的网站或者应用，dependencies中会有更多npm包，但我们现在专注于构建过程。 ANNOTATED WEBPACK.SETTINGS.JS 我还使用了我在 A Bet­ter package.json for the Fron­tend arti­cle一文中讨论过的类似方法，为了封锁从项目之间配置变为单独的webpack.settings.js，并保持webpack配置本身不变。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Macbook利用双网卡同时连内外网]]></title>
    <url>%2F2018%2F12%2F10%2FmacRouteConfig%2F</url>
    <content type="text"><![CDATA[很多单位为了安全，需要使用网线连接内网，此时不能连接外网，无线可以连接外网，却又不能完成部分在内网才能完成的操作。windows下使用双网卡的配置还比较常见，同样移植到mac下，却有许多小问题，本文将详细讲述一下macOS底下应该怎样配置路由表，实现双网卡同时连接内外网。 首先，先查看一下路由表，了解一下基本情况打开终端，输入1netstat -rt 查看路由表的配置情况，我的如下 解释一下这其中的参数123456789101112131. 第一列：Destination，目标地，意思是：后面的参数代表着，如果前往这个ip的话，应该如何分配网关，网卡等，以及状态信息，都是针对前往这个ip的情况的1. 第二列：Gateway，网关，意思是：如果需要前往这个ip，应该从哪个网关过去，这里有两种情况，即有内外网用不同网关的，也有内外网用相同网关的。2/1. 第三列：Flags，标志位，和本文的重点无关，暂略1. 第四列：Refs，可以简单的理解为重要性，相同的ip，相同的网关，用这个重要性来区分使用哪个网卡1. 第五列：Use，使用情况1. 第六列：Netif，网卡号，net interface，如图，我有两张网卡，这里的en0，en10分别代表了我的两张网卡，不同的机器名称可能不同，但是意思是一样的，至于那张是无线网卡，需要自己去区分1. 第七列：Expire，和本文的重点无关，暂略 然后明确一下我们应该如何修改看一下我的原始的表 原始表插上网线之后，我的表是这样的，当前的状况是连的上内网，连不上外网。 根据表上看到，default目标两张网卡可以走，但是refs下看到en10的优先级比较高，根据我的状况，外网地址都无法访问，外网地址属于default部分，所以得出判断en10是有线网卡，因为它的优先级较高导致去外网的ip都由有线网卡进行转发，所以上不了网了，那么自然，en0就是无线网卡。 开始修改第一步：修改无线网卡的优先级，使之大于有线网卡修改无线网卡的优先级进入系统偏好设置，网络，左下角的齿轮，更改服务顺序，拖动wifi到有线网卡上面就可以了（我的有线网卡是AX88772A） 此时变成的状态是连着无线，插着网卡，以无线网卡优先，即上不了内网，可以上外网（苹果默认的是插上有线网络有线优先） 第二步：修改连接内网使用的网卡这里有两种情况 一、公司里内外网分两个路由：此时只需要修改前往公司内网地址的网关就可以了，比如你需要访问的内网地址是10.10.15.*，而公司的内网网关是10.10.15.255，那么就这样写1sudo route add -net 10.10.15.0 -netmask 255.255.255.0 10.10.15.255&apos; 其中，0表示的是默认default，netmask是子网掩码，不是重点就不提了。 二、公司里内外网是一个路由：此时需要有线网卡转发内网链接，无线网卡转发外网链接，写法如下1sudo route add -net 10.10.15.0 -netmask 255.255.255.0 -interface en10 如果存在的话先sudo route delete一下。 至此，应该是修改完成了，可以试一试，应该是确实是内外网都可以正常访问了 第三步：如何自动在每次启动的时候都切换到当前的路由表当mac每次重启的时候，路由表都会被重置，这在windows里也是一样，但是windows里可以永久的修改路由表，而我们不希望这么做，那么就用到了macOS里好用的小机器人 Automator Automator它在mac自带的工具里，我们打开它，选择应用程序，在第二列中选择运行AppleScript，随后我们就要在Automator中编写一段mac的自动化脚本。 写入脚本把我们刚刚编辑的内容都用系统管理员权限写入脚本，并保存成一个应用程序就可以了，以后每次开机，都只需要双击就可以重新恢复路由配置。如果还需要更简便一点的话，只需要在系统偏好，用户与群组中，登录项里加入这个Automator的小程序就可以了 在登录项中加入Automator小程序完成，这样每次启动的时候都会恢复至当前的路由配置了 总结拥有的资源就要良好的利用起来，两块网卡，为什么不能同时连接内外网？搞懂了原理，才能方便生活！]]></content>
      <categories>
        <category>Mac使用</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
